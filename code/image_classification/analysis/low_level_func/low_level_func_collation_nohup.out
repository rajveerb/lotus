Running /mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py for run 1
vtune: Warning: Pause command is not supported for managed code profiling. Runtime overhead is still possible. Data size limit may be exceeded.
vtune: Collection paused.
EMON collector successfully paused.
vtune: Collection paused.
vtune: Collection resumed.
vtune: Collection detached.
vtune: Collection stopped.
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions  0 % Finalizing the result                            
vtune: Executing actions  0 % Clearing the database                            
vtune: Executing actions  7 % Clearing the database                            
vtune: Executing actions  7 % Loading raw data to the database                 
vtune: Executing actions  7 % Loading 'systemcollector-565850-c4130-node.v100ub
vtune: Executing actions 12 % Loading 'systemcollector-565850-c4130-node.v100ub
vtune: Executing actions 12 % Loading '565850-565855.0.trace' file             
vtune: Executing actions 12 % Loading 'userapicollector-565855-9a736f94.trace' 
vtune: Executing actions 12 % Loading '/mydata/rbachkaniwala3/code/rajveerb-ml-
vtune: Executing actions 12 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Setting data model parameters                    
vtune: Executing actions 19 % Resolving module symbols                         
vtune: Executing actions 19 % Resolving information for dangling locations     
vtune: Executing actions 19 % Resolving information for `libc.so.6'            
vtune: Executing actions 19 % Resolving information for `libpthread.so.0'      
vtune: Executing actions 19 % Resolving information for `libgomp.so.1'         
vtune: Executing actions 19 % Resolving information for `libtpsstool.so'       
vtune: Executing actions 19 % Resolving information for `python3.10'           
vtune: Executing actions 19 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 20 % Resolving information for `libtorch_python.so'   
vtune: Warning: Cannot locate debugging information for file `/opt/intel/oneapi/vtune/2024.0/lib64/libtpsstool.so'.
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_python.so'.

vtune: Executing actions 21 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 21 % Resolving information for `libtorch_cpu.so'      
vtune: Executing actions 22 % Resolving information for `libtorch_cpu.so'      
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_cpu.so'.

vtune: Executing actions 22 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving thread name information                
vtune: Executing actions 24 % Resolving thread name information                
vtune: Executing actions 24 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving interrupt name information             
vtune: Executing actions 26 % Resolving interrupt name information             
vtune: Executing actions 26 % Processing profile metrics and debug information 
vtune: Executing actions 28 % Processing profile metrics and debug information 
vtune: Executing actions 30 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Setting data model parameters                    
vtune: Executing actions 32 % Setting data model parameters                    
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 33 % Precomputing frequently used data                
vtune: Executing actions 35 % Precomputing frequently used data                
vtune: Executing actions 36 % Precomputing frequently used data                
vtune: Executing actions 38 % Precomputing frequently used data                
vtune: Executing actions 38 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Discarding redundant overtime data               
vtune: Executing actions 41 % Discarding redundant overtime data               
vtune: Executing actions 41 % Saving the result                                
vtune: Executing actions 42 % Saving the result                                
vtune: Executing actions 44 % Saving the result                                
vtune: Executing actions 50 % Saving the result                                
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              Elapsed Time: 19.559s
    CPU Time: 13.815s
        Effective Time: 8.183s
        Spin Time: 5.564s
         | A significant portion of CPU time is spent waiting. Use this metric
         | to discover which synchronizations are spinning. Consider adjusting
         | spin wait parameters, changing the lock implementation (for example,
         | by backing off then descheduling), or adjusting the synchronization
         | granularity.
         |
            Imbalance or Serial Spinning: 3.435s
             | The threading runtime function related to time spent on imbalance
             | or serial spinning consumed a significant amount of CPU time.
             | This can be caused by a load imbalance, insufficient concurrency
             | for all working threads, or busy waits of worker threads while
             | serial code is executed. If there is an imbalance, apply dynamic
             | work scheduling or reduce the size of work chunks or tasks. If
             | there is insufficient concurrency, consider collapsing the outer
             | and inner loops. If there is a wait for completion of serial
             | code, explore options for parallelization with Intel Advisor,
             | algorithm, or microarchitecture tuning of the application's
             | serial code with VTune Profiler Basic Hotspots or
             | Microarchitecture Exploration analysis respectively. For OpenMP*
             | applications, use the Per-Barrier OpenMP Potential Gain metric
             | set in the HPC Performance Characterization analysis to discover
             | the reason for high imbalance or serial spin time.
             |
            Lock Contention: 0s
            Other: 2.129s
        Overhead Time: 0.068s
            Creation: 0.028s
            Scheduling: 0s
            Reduction: 0s
            Atomics: 0s
            Other: 0.040s
    Total Thread Count: 16
    Paused Time: 18.682s

Top Hotspots
Function                                                                                                                                                                                                                                                                                                                                                                                                                                                           Module           CPU Time  % of CPU Time(%)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  ---------------  --------  ----------------
c10::function_ref<void (char**, long const*, long, long)>::callback_fn<at::native::AVX2::VectorizedLoop2d<at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(float)#1}, at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(at::vec::AVX2::Vectorized<float>)#2}>>  libtorch_cpu.so    8.183s             59.2%
__kmp_fork_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1       4.684s             33.9%
GOMP_parallel                                                                                                                                                                                                                                                                                                                                                                                                                                                      libgomp.so.1       0.494s              3.6%
__kmp_join_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1       0.426s              3.1%
[OpenMP dispatcher]                                                                                                                                                                                                                                                                                                                                                                                                                                                libgomp.so.1       0.020s              0.1%
__GI___pthread_getspecific                                                                                                                                                                                                                                                                                                                                                                                                                                         libpthread.so.0    0.008s              0.1%
Effective Physical Core Utilization: 67.5% (10.800 out of 16)
 | The metric value is low, which may signal a poor physical CPU cores
 | utilization caused by:
 |     - load imbalance
 |     - threading runtime overhead
 |     - contended synchronization
 |     - thread/process underutilization
 |     - incorrect affinity that utilizes logical cores instead of physical
 |       cores
 | Explore sub-metrics to estimate the efficiency of MPI and OpenMP parallelism
 | or run the Locks and Waits analysis to identify parallel bottlenecks for
 | other parallel runtimes.
 |
    Effective Logical Core Utilization: 58.2% (18.634 out of 32)
     | The metric value is low, which may signal a poor logical CPU cores
     | utilization. Consider improving physical core utilization as the first
     | step and then look at opportunities to utilize logical cores, which in
     | some cases can improve processor throughput and overall performance of
     | multi-threaded applications.
     |
Collection and Platform Info
    Application Command Line: /proj/prismgt-PG0/anaconda3/envs/torch2/bin/python "/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py" 
    Operating System: 5.4.0-164-generic DISTRIB_ID=Ubuntu DISTRIB_RELEASE=20.04 DISTRIB_CODENAME=focal DISTRIB_DESCRIPTION="Ubuntu 20.04 LTS"
    Computer Name: c4130-node.v100ubuntu20.prismgt-pg0.wisc.cloudlab.us
    Result Size: 4.8 MB 
    Collection start time: 03:28:33 02/01/2024 UTC
    Collection stop time: 03:28:53 02/01/2024 UTC
    Collector Type: Event-based counting driver,User-mode sampling and tracing
    CPU
        Name: Intel(R) Xeon(R) Processor code named Broadwell
        Frequency: 3.200 GHz
        Logical CPU Count: 32
        LLC size: 26.2 MB 
        Cache Allocation Technology
            Level 2 capability: not detected
            Level 3 capability: available

If you want to skip descriptions of detected performance issues in the report,
enter: vtune -report summary -report-knob show-issues=false -r <my_result_dir>.
Alternatively, you may view the report in the csv format: vtune -report
<report_name> -format=csv.

vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions 50 % Finalizing results                               
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              
vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
Running /mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py for run 2
vtune: Warning: Pause command is not supported for managed code profiling. Runtime overhead is still possible. Data size limit may be exceeded.
vtune: Collection paused.
EMON collector successfully paused.
vtune: Collection paused.
vtune: Collection resumed.
vtune: Collection detached.
vtune: Collection stopped.
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions  0 % Finalizing the result                            
vtune: Executing actions  0 % Clearing the database                            
vtune: Executing actions  7 % Clearing the database                            
vtune: Executing actions  7 % Loading raw data to the database                 
vtune: Executing actions  7 % Loading 'systemcollector-566058-c4130-node.v100ub
vtune: Executing actions 12 % Loading 'systemcollector-566058-c4130-node.v100ub
vtune: Executing actions 12 % Loading '566058-566063.0.trace' file             
vtune: Executing actions 12 % Loading 'userapicollector-566063-6d1a8fbc.trace' 
vtune: Executing actions 12 % Loading '/mydata/rbachkaniwala3/code/rajveerb-ml-
vtune: Executing actions 12 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Setting data model parameters                    
vtune: Executing actions 19 % Resolving module symbols                         
vtune: Executing actions 19 % Resolving information for dangling locations     
vtune: Executing actions 19 % Resolving information for `libc.so.6'            
vtune: Executing actions 19 % Resolving information for `libpthread.so.0'      
vtune: Executing actions 19 % Resolving information for `libgomp.so.1'         
vtune: Executing actions 19 % Resolving information for `libtpsstool.so'       
vtune: Executing actions 19 % Resolving information for `python3.10'           
vtune: Executing actions 19 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 20 % Resolving information for `libtorch_python.so'   
vtune: Warning: Cannot locate debugging information for file `/opt/intel/oneapi/vtune/2024.0/lib64/libtpsstool.so'.
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_python.so'.

vtune: Executing actions 21 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 22 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 22 % Resolving information for `libtorch_cpu.so'      
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_cpu.so'.

vtune: Executing actions 22 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving thread name information                
vtune: Executing actions 24 % Resolving thread name information                
vtune: Executing actions 24 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving interrupt name information             
vtune: Executing actions 26 % Resolving interrupt name information             
vtune: Executing actions 26 % Processing profile metrics and debug information 
vtune: Executing actions 28 % Processing profile metrics and debug information 
vtune: Executing actions 30 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Setting data model parameters                    
vtune: Executing actions 32 % Setting data model parameters                    
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 33 % Precomputing frequently used data                
vtune: Executing actions 35 % Precomputing frequently used data                
vtune: Executing actions 36 % Precomputing frequently used data                
vtune: Executing actions 38 % Precomputing frequently used data                
vtune: Executing actions 38 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Discarding redundant overtime data               
vtune: Executing actions 41 % Discarding redundant overtime data               
vtune: Executing actions 41 % Saving the result                                
vtune: Executing actions 42 % Saving the result                                
vtune: Executing actions 44 % Saving the result                                
vtune: Executing actions 50 % Saving the result                                
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              Elapsed Time: 19.595s
    CPU Time: 13.027s
        Effective Time: 7.498s
        Spin Time: 5.485s
         | A significant portion of CPU time is spent waiting. Use this metric
         | to discover which synchronizations are spinning. Consider adjusting
         | spin wait parameters, changing the lock implementation (for example,
         | by backing off then descheduling), or adjusting the synchronization
         | granularity.
         |
            Imbalance or Serial Spinning: 3.338s
             | The threading runtime function related to time spent on imbalance
             | or serial spinning consumed a significant amount of CPU time.
             | This can be caused by a load imbalance, insufficient concurrency
             | for all working threads, or busy waits of worker threads while
             | serial code is executed. If there is an imbalance, apply dynamic
             | work scheduling or reduce the size of work chunks or tasks. If
             | there is insufficient concurrency, consider collapsing the outer
             | and inner loops. If there is a wait for completion of serial
             | code, explore options for parallelization with Intel Advisor,
             | algorithm, or microarchitecture tuning of the application's
             | serial code with VTune Profiler Basic Hotspots or
             | Microarchitecture Exploration analysis respectively. For OpenMP*
             | applications, use the Per-Barrier OpenMP Potential Gain metric
             | set in the HPC Performance Characterization analysis to discover
             | the reason for high imbalance or serial spin time.
             |
            Lock Contention: 0s
            Other: 2.147s
        Overhead Time: 0.044s
            Creation: 0s
            Scheduling: 0s
            Reduction: 0s
            Atomics: 0s
            Other: 0.044s
    Total Thread Count: 16
    Paused Time: 18.777s

Top Hotspots
Function                                                                                                                                                                                                                                                                                                                                                                                                                                                           Module           CPU Time  % of CPU Time(%)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  ---------------  --------  ----------------
c10::function_ref<void (char**, long const*, long, long)>::callback_fn<at::native::AVX2::VectorizedLoop2d<at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(float)#1}, at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(at::vec::AVX2::Vectorized<float>)#2}>>  libtorch_cpu.so    7.498s             57.6%
__kmp_fork_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1       4.267s             32.8%
__kmp_join_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1       0.665s              5.1%
GOMP_parallel                                                                                                                                                                                                                                                                                                                                                                                                                                                      libgomp.so.1       0.597s              4.6%
Effective Physical Core Utilization: 57.4% (9.189 out of 16)
 | The metric value is low, which may signal a poor physical CPU cores
 | utilization caused by:
 |     - load imbalance
 |     - threading runtime overhead
 |     - contended synchronization
 |     - thread/process underutilization
 |     - incorrect affinity that utilizes logical cores instead of physical
 |       cores
 | Explore sub-metrics to estimate the efficiency of MPI and OpenMP parallelism
 | or run the Locks and Waits analysis to identify parallel bottlenecks for
 | other parallel runtimes.
 |
    Effective Logical Core Utilization: 49.0% (15.667 out of 32)
     | The metric value is low, which may signal a poor logical CPU cores
     | utilization. Consider improving physical core utilization as the first
     | step and then look at opportunities to utilize logical cores, which in
     | some cases can improve processor throughput and overall performance of
     | multi-threaded applications.
     |
Collection and Platform Info
    Application Command Line: /proj/prismgt-PG0/anaconda3/envs/torch2/bin/python "/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py" 
    Operating System: 5.4.0-164-generic DISTRIB_ID=Ubuntu DISTRIB_RELEASE=20.04 DISTRIB_CODENAME=focal DISTRIB_DESCRIPTION="Ubuntu 20.04 LTS"
    Computer Name: c4130-node.v100ubuntu20.prismgt-pg0.wisc.cloudlab.us
    Result Size: 4.8 MB 
    Collection start time: 03:29:11 02/01/2024 UTC
    Collection stop time: 03:29:31 02/01/2024 UTC
    Collector Type: Event-based counting driver,User-mode sampling and tracing
    CPU
        Name: Intel(R) Xeon(R) Processor code named Broadwell
        Frequency: 3.200 GHz
        Logical CPU Count: 32
        LLC size: 26.2 MB 
        Cache Allocation Technology
            Level 2 capability: not detected
            Level 3 capability: available

If you want to skip descriptions of detected performance issues in the report,
enter: vtune -report summary -report-knob show-issues=false -r <my_result_dir>.
Alternatively, you may view the report in the csv format: vtune -report
<report_name> -format=csv.

vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions 50 % Finalizing results                               
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              
vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
Running /mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py for run 3
vtune: Warning: Pause command is not supported for managed code profiling. Runtime overhead is still possible. Data size limit may be exceeded.
vtune: Collection paused.
EMON collector successfully paused.
vtune: Collection paused.
vtune: Collection resumed.
vtune: Collection detached.
vtune: Collection stopped.
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions  0 % Finalizing the result                            
vtune: Executing actions  0 % Clearing the database                            
vtune: Executing actions  7 % Clearing the database                            
vtune: Executing actions  7 % Loading raw data to the database                 
vtune: Executing actions  7 % Loading 'systemcollector-566197-c4130-node.v100ub
vtune: Executing actions 12 % Loading 'systemcollector-566197-c4130-node.v100ub
vtune: Executing actions 12 % Loading '566197-566202.0.trace' file             
vtune: Executing actions 12 % Loading 'userapicollector-566202-d2a8c471.trace' 
vtune: Executing actions 12 % Loading '/mydata/rbachkaniwala3/code/rajveerb-ml-
vtune: Executing actions 12 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Setting data model parameters                    
vtune: Executing actions 19 % Resolving module symbols                         
vtune: Executing actions 19 % Resolving information for dangling locations     
vtune: Executing actions 19 % Resolving information for `libc.so.6'            
vtune: Executing actions 19 % Resolving information for `libpthread.so.0'      
vtune: Executing actions 19 % Resolving information for `libgomp.so.1'         
vtune: Executing actions 19 % Resolving information for `libtpsstool.so'       
vtune: Executing actions 19 % Resolving information for `python3.10'           
vtune: Executing actions 19 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 20 % Resolving information for `libtorch_python.so'   
vtune: Warning: Cannot locate debugging information for file `/opt/intel/oneapi/vtune/2024.0/lib64/libtpsstool.so'.
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_python.so'.

vtune: Executing actions 21 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 21 % Resolving information for `libtorch_cpu.so'      
vtune: Executing actions 22 % Resolving information for `libtorch_cpu.so'      
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_cpu.so'.

vtune: Executing actions 22 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving thread name information                
vtune: Executing actions 24 % Resolving thread name information                
vtune: Executing actions 24 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving interrupt name information             
vtune: Executing actions 26 % Resolving interrupt name information             
vtune: Executing actions 26 % Processing profile metrics and debug information 
vtune: Executing actions 28 % Processing profile metrics and debug information 
vtune: Executing actions 30 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Setting data model parameters                    
vtune: Executing actions 32 % Setting data model parameters                    
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 33 % Precomputing frequently used data                
vtune: Executing actions 35 % Precomputing frequently used data                
vtune: Executing actions 36 % Precomputing frequently used data                
vtune: Executing actions 38 % Precomputing frequently used data                
vtune: Executing actions 38 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Discarding redundant overtime data               
vtune: Executing actions 41 % Discarding redundant overtime data               
vtune: Executing actions 41 % Saving the result                                
vtune: Executing actions 42 % Saving the result                                
vtune: Executing actions 44 % Saving the result                                
vtune: Executing actions 49 % Saving the result                                
vtune: Executing actions 50 % Saving the result                                
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              Elapsed Time: 19.514s
    CPU Time: 11.393s
        Effective Time: 5.371s
        Spin Time: 6.001s
         | A significant portion of CPU time is spent waiting. Use this metric
         | to discover which synchronizations are spinning. Consider adjusting
         | spin wait parameters, changing the lock implementation (for example,
         | by backing off then descheduling), or adjusting the synchronization
         | granularity.
         |
            Imbalance or Serial Spinning: 3.803s
             | The threading runtime function related to time spent on imbalance
             | or serial spinning consumed a significant amount of CPU time.
             | This can be caused by a load imbalance, insufficient concurrency
             | for all working threads, or busy waits of worker threads while
             | serial code is executed. If there is an imbalance, apply dynamic
             | work scheduling or reduce the size of work chunks or tasks. If
             | there is insufficient concurrency, consider collapsing the outer
             | and inner loops. If there is a wait for completion of serial
             | code, explore options for parallelization with Intel Advisor,
             | algorithm, or microarchitecture tuning of the application's
             | serial code with VTune Profiler Basic Hotspots or
             | Microarchitecture Exploration analysis respectively. For OpenMP*
             | applications, use the Per-Barrier OpenMP Potential Gain metric
             | set in the HPC Performance Characterization analysis to discover
             | the reason for high imbalance or serial spin time.
             |
            Lock Contention: 0s
            Other: 2.198s
        Overhead Time: 0.020s
            Creation: 0s
            Scheduling: 0s
            Reduction: 0s
            Atomics: 0s
            Other: 0.020s
    Total Thread Count: 16
    Paused Time: 18.796s

Top Hotspots
Function                                                                                                                                                                                                                                                                                                                                                                                                                                                           Module           CPU Time  % of CPU Time(%)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  ---------------  --------  ----------------
c10::function_ref<void (char**, long const*, long, long)>::callback_fn<at::native::AVX2::VectorizedLoop2d<at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(float)#1}, at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(at::vec::AVX2::Vectorized<float>)#2}>>  libtorch_cpu.so    5.371s             47.1%
__kmp_fork_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1       4.950s             43.5%
__kmp_join_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1       0.599s              5.3%
GOMP_parallel                                                                                                                                                                                                                                                                                                                                                                                                                                                      libgomp.so.1       0.472s              4.1%
Effective Physical Core Utilization: 66.5% (10.633 out of 16)
 | The metric value is low, which may signal a poor physical CPU cores
 | utilization caused by:
 |     - load imbalance
 |     - threading runtime overhead
 |     - contended synchronization
 |     - thread/process underutilization
 |     - incorrect affinity that utilizes logical cores instead of physical
 |       cores
 | Explore sub-metrics to estimate the efficiency of MPI and OpenMP parallelism
 | or run the Locks and Waits analysis to identify parallel bottlenecks for
 | other parallel runtimes.
 |
    Effective Logical Core Utilization: 56.4% (18.039 out of 32)
     | The metric value is low, which may signal a poor logical CPU cores
     | utilization. Consider improving physical core utilization as the first
     | step and then look at opportunities to utilize logical cores, which in
     | some cases can improve processor throughput and overall performance of
     | multi-threaded applications.
     |
Collection and Platform Info
    Application Command Line: /proj/prismgt-PG0/anaconda3/envs/torch2/bin/python "/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py" 
    Operating System: 5.4.0-164-generic DISTRIB_ID=Ubuntu DISTRIB_RELEASE=20.04 DISTRIB_CODENAME=focal DISTRIB_DESCRIPTION="Ubuntu 20.04 LTS"
    Computer Name: c4130-node.v100ubuntu20.prismgt-pg0.wisc.cloudlab.us
    Result Size: 4.7 MB 
    Collection start time: 03:29:47 02/01/2024 UTC
    Collection stop time: 03:30:07 02/01/2024 UTC
    Collector Type: Event-based counting driver,User-mode sampling and tracing
    CPU
        Name: Intel(R) Xeon(R) Processor code named Broadwell
        Frequency: 3.200 GHz
        Logical CPU Count: 32
        LLC size: 26.2 MB 
        Cache Allocation Technology
            Level 2 capability: not detected
            Level 3 capability: available

If you want to skip descriptions of detected performance issues in the report,
enter: vtune -report summary -report-knob show-issues=false -r <my_result_dir>.
Alternatively, you may view the report in the csv format: vtune -report
<report_name> -format=csv.

vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions 50 % Finalizing results                               
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              
vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
Running /mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py for run 4
vtune: Warning: Pause command is not supported for managed code profiling. Runtime overhead is still possible. Data size limit may be exceeded.
vtune: Collection paused.
EMON collector successfully paused.
vtune: Collection paused.
vtune: Collection resumed.
vtune: Collection detached.
vtune: Collection stopped.
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions  0 % Finalizing the result                            
vtune: Executing actions  0 % Clearing the database                            
vtune: Executing actions  7 % Clearing the database                            
vtune: Executing actions  7 % Loading raw data to the database                 
vtune: Executing actions  7 % Loading 'systemcollector-566343-c4130-node.v100ub
vtune: Executing actions 12 % Loading 'systemcollector-566343-c4130-node.v100ub
vtune: Executing actions 12 % Loading '566343-566348.0.trace' file             
vtune: Executing actions 12 % Loading 'userapicollector-566348-2c8c2226.trace' 
vtune: Executing actions 12 % Loading '/mydata/rbachkaniwala3/code/rajveerb-ml-
vtune: Executing actions 12 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Setting data model parameters                    
vtune: Executing actions 19 % Resolving module symbols                         
vtune: Executing actions 19 % Resolving information for dangling locations     
vtune: Executing actions 19 % Resolving information for `libc.so.6'            
vtune: Executing actions 19 % Resolving information for `ld-linux-x86-64.so.2' 
vtune: Executing actions 19 % Resolving information for `libgomp.so.1'         
vtune: Executing actions 19 % Resolving information for `libpthread.so.0'      
vtune: Executing actions 19 % Resolving information for `libtpsstool.so'       
vtune: Executing actions 20 % Resolving information for `libtpsstool.so'       
vtune: Executing actions 20 % Resolving information for `python3.10'           
vtune: Executing actions 20 % Resolving information for `libtorch_python.so'   
vtune: Warning: Cannot locate debugging information for file `/opt/intel/oneapi/vtune/2024.0/lib64/libtpsstool.so'.
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_python.so'.

vtune: Executing actions 21 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 21 % Resolving information for `libtorch_cpu.so'      
vtune: Executing actions 22 % Resolving information for `libtorch_cpu.so'      
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_cpu.so'.

vtune: Executing actions 22 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving thread name information                
vtune: Executing actions 24 % Resolving thread name information                
vtune: Executing actions 24 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving interrupt name information             
vtune: Executing actions 26 % Resolving interrupt name information             
vtune: Executing actions 26 % Processing profile metrics and debug information 
vtune: Executing actions 28 % Processing profile metrics and debug information 
vtune: Executing actions 30 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Setting data model parameters                    
vtune: Executing actions 32 % Setting data model parameters                    
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 33 % Precomputing frequently used data                
vtune: Executing actions 35 % Precomputing frequently used data                
vtune: Executing actions 36 % Precomputing frequently used data                
vtune: Executing actions 38 % Precomputing frequently used data                
vtune: Executing actions 38 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Discarding redundant overtime data               
vtune: Executing actions 41 % Discarding redundant overtime data               
vtune: Executing actions 41 % Saving the result                                
vtune: Executing actions 42 % Saving the result                                
vtune: Executing actions 44 % Saving the result                                
vtune: Executing actions 50 % Saving the result                                
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              Elapsed Time: 19.358s
    CPU Time: 13.083s
        Effective Time: 7.205s
        Spin Time: 5.846s
         | A significant portion of CPU time is spent waiting. Use this metric
         | to discover which synchronizations are spinning. Consider adjusting
         | spin wait parameters, changing the lock implementation (for example,
         | by backing off then descheduling), or adjusting the synchronization
         | granularity.
         |
            Imbalance or Serial Spinning: 3.333s
             | The threading runtime function related to time spent on imbalance
             | or serial spinning consumed a significant amount of CPU time.
             | This can be caused by a load imbalance, insufficient concurrency
             | for all working threads, or busy waits of worker threads while
             | serial code is executed. If there is an imbalance, apply dynamic
             | work scheduling or reduce the size of work chunks or tasks. If
             | there is insufficient concurrency, consider collapsing the outer
             | and inner loops. If there is a wait for completion of serial
             | code, explore options for parallelization with Intel Advisor,
             | algorithm, or microarchitecture tuning of the application's
             | serial code with VTune Profiler Basic Hotspots or
             | Microarchitecture Exploration analysis respectively. For OpenMP*
             | applications, use the Per-Barrier OpenMP Potential Gain metric
             | set in the HPC Performance Characterization analysis to discover
             | the reason for high imbalance or serial spin time.
             |
            Lock Contention: 0s
            Other: 2.513s
        Overhead Time: 0.032s
            Creation: 0.008s
            Scheduling: 0s
            Reduction: 0s
            Atomics: 0s
            Other: 0.024s
    Total Thread Count: 16
    Paused Time: 18.534s

Top Hotspots
Function                                                                                                                                                                                                                                                                                                                                                                                                                                                           Module           CPU Time  % of CPU Time(%)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  ---------------  --------  ----------------
c10::function_ref<void (char**, long const*, long, long)>::callback_fn<at::native::AVX2::VectorizedLoop2d<at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(float)#1}, at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(at::vec::AVX2::Vectorized<float>)#2}>>  libtorch_cpu.so    7.189s             55.0%
__kmp_fork_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1       5.272s             40.3%
GOMP_parallel                                                                                                                                                                                                                                                                                                                                                                                                                                                      libgomp.so.1       0.466s              3.6%
__kmp_join_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1       0.132s              1.0%
at::native::structured_cat_out_cpu::impl                                                                                                                                                                                                                                                                                                                                                                                                                           libtorch_cpu.so    0.008s              0.1%
[Others]                                                                                                                                                                                                                                                                                                                                                                                                                                                           N/A                0.016s              0.1%
Effective Physical Core Utilization: 70.7% (11.314 out of 16)
 | The metric value is low, which may signal a poor physical CPU cores
 | utilization caused by:
 |     - load imbalance
 |     - threading runtime overhead
 |     - contended synchronization
 |     - thread/process underutilization
 |     - incorrect affinity that utilizes logical cores instead of physical
 |       cores
 | Explore sub-metrics to estimate the efficiency of MPI and OpenMP parallelism
 | or run the Locks and Waits analysis to identify parallel bottlenecks for
 | other parallel runtimes.
 |
    Effective Logical Core Utilization: 59.5% (19.025 out of 32)
     | The metric value is low, which may signal a poor logical CPU cores
     | utilization. Consider improving physical core utilization as the first
     | step and then look at opportunities to utilize logical cores, which in
     | some cases can improve processor throughput and overall performance of
     | multi-threaded applications.
     |
Collection and Platform Info
    Application Command Line: /proj/prismgt-PG0/anaconda3/envs/torch2/bin/python "/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py" 
    Operating System: 5.4.0-164-generic DISTRIB_ID=Ubuntu DISTRIB_RELEASE=20.04 DISTRIB_CODENAME=focal DISTRIB_DESCRIPTION="Ubuntu 20.04 LTS"
    Computer Name: c4130-node.v100ubuntu20.prismgt-pg0.wisc.cloudlab.us
    Result Size: 4.8 MB 
    Collection start time: 03:30:23 02/01/2024 UTC
    Collection stop time: 03:30:42 02/01/2024 UTC
    Collector Type: Event-based counting driver,User-mode sampling and tracing
    CPU
        Name: Intel(R) Xeon(R) Processor code named Broadwell
        Frequency: 3.200 GHz
        Logical CPU Count: 32
        LLC size: 26.2 MB 
        Cache Allocation Technology
            Level 2 capability: not detected
            Level 3 capability: available

If you want to skip descriptions of detected performance issues in the report,
enter: vtune -report summary -report-knob show-issues=false -r <my_result_dir>.
Alternatively, you may view the report in the csv format: vtune -report
<report_name> -format=csv.

vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions 50 % Finalizing results                               
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              
vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
Running /mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py for run 5
vtune: Warning: Pause command is not supported for managed code profiling. Runtime overhead is still possible. Data size limit may be exceeded.
vtune: Collection paused.
EMON collector successfully paused.
vtune: Collection paused.
vtune: Collection resumed.
vtune: Collection detached.
vtune: Collection stopped.
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions  0 % Finalizing the result                            
vtune: Executing actions  0 % Clearing the database                            
vtune: Executing actions  7 % Clearing the database                            
vtune: Executing actions  7 % Loading raw data to the database                 
vtune: Executing actions  7 % Loading 'systemcollector-566483-c4130-node.v100ub
vtune: Executing actions 12 % Loading 'systemcollector-566483-c4130-node.v100ub
vtune: Executing actions 12 % Loading '566483-566488.0.trace' file             
vtune: Executing actions 12 % Loading 'userapicollector-566488-03d86562.trace' 
vtune: Executing actions 12 % Loading '/mydata/rbachkaniwala3/code/rajveerb-ml-
vtune: Executing actions 12 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Setting data model parameters                    
vtune: Executing actions 19 % Resolving module symbols                         
vtune: Executing actions 19 % Resolving information for dangling locations     
vtune: Executing actions 19 % Resolving information for `libpthread.so.0'      
vtune: Executing actions 19 % Resolving information for `libc.so.6'            
vtune: Executing actions 19 % Resolving information for `libgomp.so.1'         
vtune: Executing actions 19 % Resolving information for `libtpsstool.so'       
vtune: Executing actions 19 % Resolving information for `python3.10'           
vtune: Executing actions 19 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 20 % Resolving information for `libtorch_python.so'   
vtune: Warning: Cannot locate debugging information for file `/opt/intel/oneapi/vtune/2024.0/lib64/libtpsstool.so'.
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_python.so'.

vtune: Executing actions 21 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 22 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 22 % Resolving information for `libtorch_cpu.so'      
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_cpu.so'.

vtune: Executing actions 22 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving thread name information                
vtune: Executing actions 24 % Resolving thread name information                
vtune: Executing actions 24 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving interrupt name information             
vtune: Executing actions 26 % Resolving interrupt name information             
vtune: Executing actions 26 % Processing profile metrics and debug information 
vtune: Executing actions 28 % Processing profile metrics and debug information 
vtune: Executing actions 30 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Setting data model parameters                    
vtune: Executing actions 32 % Setting data model parameters                    
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 33 % Precomputing frequently used data                
vtune: Executing actions 35 % Precomputing frequently used data                
vtune: Executing actions 36 % Precomputing frequently used data                
vtune: Executing actions 38 % Precomputing frequently used data                
vtune: Executing actions 38 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Discarding redundant overtime data               
vtune: Executing actions 41 % Discarding redundant overtime data               
vtune: Executing actions 41 % Saving the result                                
vtune: Executing actions 42 % Saving the result                                
vtune: Executing actions 44 % Saving the result                                
vtune: Executing actions 50 % Saving the result                                
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              Elapsed Time: 19.749s
    CPU Time: 5.503s
        Effective Time: 4.654s
        Spin Time: 0.769s
         | A significant portion of CPU time is spent waiting. Use this metric
         | to discover which synchronizations are spinning. Consider adjusting
         | spin wait parameters, changing the lock implementation (for example,
         | by backing off then descheduling), or adjusting the synchronization
         | granularity.
         |
            Imbalance or Serial Spinning: 0.430s
            Lock Contention: 0s
            Other: 0.339s
        Overhead Time: 0.080s
            Creation: 0s
            Scheduling: 0s
            Reduction: 0s
            Atomics: 0s
            Other: 0.080s
    Total Thread Count: 16
    Paused Time: 19.398s

Top Hotspots
Function                                                                                                                                                                                                                                                                                                                                                                                                                                                           Module           CPU Time  % of CPU Time(%)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  ---------------  --------  ----------------
c10::function_ref<void (char**, long const*, long, long)>::callback_fn<at::native::AVX2::VectorizedLoop2d<at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(float)#1}, at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(at::vec::AVX2::Vectorized<float>)#2}>>  libtorch_cpu.so    4.647s             84.4%
__kmp_fork_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1       0.693s             12.6%
GOMP_parallel                                                                                                                                                                                                                                                                                                                                                                                                                                                      libgomp.so.1       0.124s              2.3%
__kmp_join_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1       0.032s              0.6%
c10::TensorImpl::data                                                                                                                                                                                                                                                                                                                                                                                                                                              libtorch_cpu.so    0.007s              0.1%
Effective Physical Core Utilization: 54.2% (8.667 out of 16)
 | The metric value is low, which may signal a poor physical CPU cores
 | utilization caused by:
 |     - load imbalance
 |     - threading runtime overhead
 |     - contended synchronization
 |     - thread/process underutilization
 |     - incorrect affinity that utilizes logical cores instead of physical
 |       cores
 | Explore sub-metrics to estimate the efficiency of MPI and OpenMP parallelism
 | or run the Locks and Waits analysis to identify parallel bottlenecks for
 | other parallel runtimes.
 |
    Effective Logical Core Utilization: 46.2% (14.777 out of 32)
     | The metric value is low, which may signal a poor logical CPU cores
     | utilization. Consider improving physical core utilization as the first
     | step and then look at opportunities to utilize logical cores, which in
     | some cases can improve processor throughput and overall performance of
     | multi-threaded applications.
     |
Collection and Platform Info
    Application Command Line: /proj/prismgt-PG0/anaconda3/envs/torch2/bin/python "/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py" 
    Operating System: 5.4.0-164-generic DISTRIB_ID=Ubuntu DISTRIB_RELEASE=20.04 DISTRIB_CODENAME=focal DISTRIB_DESCRIPTION="Ubuntu 20.04 LTS"
    Computer Name: c4130-node.v100ubuntu20.prismgt-pg0.wisc.cloudlab.us
    Result Size: 4.6 MB 
    Collection start time: 03:31:00 02/01/2024 UTC
    Collection stop time: 03:31:20 02/01/2024 UTC
    Collector Type: Event-based counting driver,User-mode sampling and tracing
    CPU
        Name: Intel(R) Xeon(R) Processor code named Broadwell
        Frequency: 3.200 GHz
        Logical CPU Count: 32
        LLC size: 26.2 MB 
        Cache Allocation Technology
            Level 2 capability: not detected
            Level 3 capability: available

If you want to skip descriptions of detected performance issues in the report,
enter: vtune -report summary -report-knob show-issues=false -r <my_result_dir>.
Alternatively, you may view the report in the csv format: vtune -report
<report_name> -format=csv.

vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions 50 % Finalizing results                               
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              
vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
Running /mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py for run 6
vtune: Warning: Pause command is not supported for managed code profiling. Runtime overhead is still possible. Data size limit may be exceeded.
vtune: Collection paused.
EMON collector successfully paused.
vtune: Collection paused.
vtune: Collection resumed.
vtune: Collection detached.
vtune: Collection stopped.
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions  0 % Finalizing the result                            
vtune: Executing actions  0 % Clearing the database                            
vtune: Executing actions  7 % Clearing the database                            
vtune: Executing actions  7 % Loading raw data to the database                 
vtune: Executing actions  7 % Loading 'systemcollector-566621-c4130-node.v100ub
vtune: Executing actions 12 % Loading 'systemcollector-566621-c4130-node.v100ub
vtune: Executing actions 12 % Loading '566621-566626.0.trace' file             
vtune: Executing actions 12 % Loading 'userapicollector-566626-989cce1c.trace' 
vtune: Executing actions 12 % Loading '/mydata/rbachkaniwala3/code/rajveerb-ml-
vtune: Executing actions 12 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Setting data model parameters                    
vtune: Executing actions 19 % Resolving module symbols                         
vtune: Executing actions 19 % Resolving information for dangling locations     
vtune: Executing actions 19 % Resolving information for `libpthread.so.0'      
vtune: Executing actions 19 % Resolving information for `libc.so.6'            
vtune: Executing actions 19 % Resolving information for `libgomp.so.1'         
vtune: Executing actions 19 % Resolving information for `libtpsstool.so'       
vtune: Executing actions 19 % Resolving information for `python3.10'           
vtune: Executing actions 19 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 20 % Resolving information for `libtorch_python.so'   
vtune: Warning: Cannot locate debugging information for file `/opt/intel/oneapi/vtune/2024.0/lib64/libtpsstool.so'.
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_python.so'.

vtune: Executing actions 21 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 21 % Resolving information for `libtorch_cpu.so'      
vtune: Executing actions 22 % Resolving information for `libtorch_cpu.so'      
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_cpu.so'.

vtune: Executing actions 22 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving thread name information                
vtune: Executing actions 24 % Resolving thread name information                
vtune: Executing actions 24 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving interrupt name information             
vtune: Executing actions 26 % Resolving interrupt name information             
vtune: Executing actions 26 % Processing profile metrics and debug information 
vtune: Executing actions 28 % Processing profile metrics and debug information 
vtune: Executing actions 30 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Setting data model parameters                    
vtune: Executing actions 32 % Setting data model parameters                    
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 33 % Precomputing frequently used data                
vtune: Executing actions 35 % Precomputing frequently used data                
vtune: Executing actions 36 % Precomputing frequently used data                
vtune: Executing actions 38 % Precomputing frequently used data                
vtune: Executing actions 38 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Discarding redundant overtime data               
vtune: Executing actions 41 % Discarding redundant overtime data               
vtune: Executing actions 41 % Saving the result                                
vtune: Executing actions 42 % Saving the result                                
vtune: Executing actions 44 % Saving the result                                
vtune: Executing actions 50 % Saving the result                                
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              Elapsed Time: 19.092s
    CPU Time: 10.554s
        Effective Time: 6.113s
        Spin Time: 4.373s
         | A significant portion of CPU time is spent waiting. Use this metric
         | to discover which synchronizations are spinning. Consider adjusting
         | spin wait parameters, changing the lock implementation (for example,
         | by backing off then descheduling), or adjusting the synchronization
         | granularity.
         |
            Imbalance or Serial Spinning: 2.651s
             | The threading runtime function related to time spent on imbalance
             | or serial spinning consumed a significant amount of CPU time.
             | This can be caused by a load imbalance, insufficient concurrency
             | for all working threads, or busy waits of worker threads while
             | serial code is executed. If there is an imbalance, apply dynamic
             | work scheduling or reduce the size of work chunks or tasks. If
             | there is insufficient concurrency, consider collapsing the outer
             | and inner loops. If there is a wait for completion of serial
             | code, explore options for parallelization with Intel Advisor,
             | algorithm, or microarchitecture tuning of the application's
             | serial code with VTune Profiler Basic Hotspots or
             | Microarchitecture Exploration analysis respectively. For OpenMP*
             | applications, use the Per-Barrier OpenMP Potential Gain metric
             | set in the HPC Performance Characterization analysis to discover
             | the reason for high imbalance or serial spin time.
             |
            Lock Contention: 0s
            Other: 1.722s
        Overhead Time: 0.068s
            Creation: 0.036s
            Scheduling: 0s
            Reduction: 0s
            Atomics: 0s
            Other: 0.032s
    Total Thread Count: 16
    Paused Time: 18.423s

Top Hotspots
Function                                                                                                                                                                                                                                                                                                                                                                                                                                                           Module           CPU Time  % of CPU Time(%)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  ---------------  --------  ----------------
c10::function_ref<void (char**, long const*, long, long)>::callback_fn<at::native::AVX2::VectorizedLoop2d<at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(float)#1}, at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(at::vec::AVX2::Vectorized<float>)#2}>>  libtorch_cpu.so    6.105s             57.8%
__kmp_fork_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1       3.771s             35.7%
GOMP_parallel                                                                                                                                                                                                                                                                                                                                                                                                                                                      libgomp.so.1       0.350s              3.3%
__kmp_join_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1       0.272s              2.6%
[OpenMP dispatcher]                                                                                                                                                                                                                                                                                                                                                                                                                                                libgomp.so.1       0.024s              0.2%
[Others]                                                                                                                                                                                                                                                                                                                                                                                                                                                           N/A                0.032s              0.3%
Effective Physical Core Utilization: 63.3% (10.130 out of 16)
 | The metric value is low, which may signal a poor physical CPU cores
 | utilization caused by:
 |     - load imbalance
 |     - threading runtime overhead
 |     - contended synchronization
 |     - thread/process underutilization
 |     - incorrect affinity that utilizes logical cores instead of physical
 |       cores
 | Explore sub-metrics to estimate the efficiency of MPI and OpenMP parallelism
 | or run the Locks and Waits analysis to identify parallel bottlenecks for
 | other parallel runtimes.
 |
    Effective Logical Core Utilization: 58.3% (18.646 out of 32)
     | The metric value is low, which may signal a poor logical CPU cores
     | utilization. Consider improving physical core utilization as the first
     | step and then look at opportunities to utilize logical cores, which in
     | some cases can improve processor throughput and overall performance of
     | multi-threaded applications.
     |
Collection and Platform Info
    Application Command Line: /proj/prismgt-PG0/anaconda3/envs/torch2/bin/python "/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py" 
    Operating System: 5.4.0-164-generic DISTRIB_ID=Ubuntu DISTRIB_RELEASE=20.04 DISTRIB_CODENAME=focal DISTRIB_DESCRIPTION="Ubuntu 20.04 LTS"
    Computer Name: c4130-node.v100ubuntu20.prismgt-pg0.wisc.cloudlab.us
    Result Size: 4.7 MB 
    Collection start time: 03:31:38 02/01/2024 UTC
    Collection stop time: 03:31:57 02/01/2024 UTC
    Collector Type: Event-based counting driver,User-mode sampling and tracing
    CPU
        Name: Intel(R) Xeon(R) Processor code named Broadwell
        Frequency: 3.200 GHz
        Logical CPU Count: 32
        LLC size: 26.2 MB 
        Cache Allocation Technology
            Level 2 capability: not detected
            Level 3 capability: available

If you want to skip descriptions of detected performance issues in the report,
enter: vtune -report summary -report-knob show-issues=false -r <my_result_dir>.
Alternatively, you may view the report in the csv format: vtune -report
<report_name> -format=csv.

vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions 50 % Finalizing results                               
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              
vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
Running /mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py for run 7
vtune: Warning: Pause command is not supported for managed code profiling. Runtime overhead is still possible. Data size limit may be exceeded.
vtune: Collection paused.
EMON collector successfully paused.
vtune: Collection paused.
vtune: Collection resumed.
vtune: Collection detached.
vtune: Collection stopped.
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions  0 % Finalizing the result                            
vtune: Executing actions  0 % Clearing the database                            
vtune: Executing actions  7 % Clearing the database                            
vtune: Executing actions  7 % Loading raw data to the database                 
vtune: Executing actions  7 % Loading 'systemcollector-566756-c4130-node.v100ub
vtune: Executing actions 12 % Loading 'systemcollector-566756-c4130-node.v100ub
vtune: Executing actions 12 % Loading '566756-566761.0.trace' file             
vtune: Executing actions 12 % Loading 'userapicollector-566761-1a158374.trace' 
vtune: Executing actions 12 % Loading '/mydata/rbachkaniwala3/code/rajveerb-ml-
vtune: Executing actions 12 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Setting data model parameters                    
vtune: Executing actions 19 % Resolving module symbols                         
vtune: Executing actions 19 % Resolving information for dangling locations     
vtune: Executing actions 19 % Resolving information for `libc.so.6'            
vtune: Executing actions 19 % Resolving information for `libpthread.so.0'      
vtune: Executing actions 19 % Resolving information for `libgomp.so.1'         
vtune: Executing actions 19 % Resolving information for `libtpsstool.so'       
vtune: Executing actions 19 % Resolving information for `python3.10'           
vtune: Executing actions 19 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 20 % Resolving information for `libtorch_python.so'   
vtune: Warning: Cannot locate debugging information for file `/opt/intel/oneapi/vtune/2024.0/lib64/libtpsstool.so'.
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_python.so'.

vtune: Executing actions 21 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 22 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 22 % Resolving information for `libtorch_cpu.so'      
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_cpu.so'.

vtune: Executing actions 22 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving thread name information                
vtune: Executing actions 24 % Resolving thread name information                
vtune: Executing actions 24 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving interrupt name information             
vtune: Executing actions 26 % Resolving interrupt name information             
vtune: Executing actions 26 % Processing profile metrics and debug information 
vtune: Executing actions 28 % Processing profile metrics and debug information 
vtune: Executing actions 30 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Setting data model parameters                    
vtune: Executing actions 32 % Setting data model parameters                    
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 33 % Precomputing frequently used data                
vtune: Executing actions 35 % Precomputing frequently used data                
vtune: Executing actions 36 % Precomputing frequently used data                
vtune: Executing actions 38 % Precomputing frequently used data                
vtune: Executing actions 38 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Discarding redundant overtime data               
vtune: Executing actions 41 % Discarding redundant overtime data               
vtune: Executing actions 41 % Saving the result                                
vtune: Executing actions 42 % Saving the result                                
vtune: Executing actions 44 % Saving the result                                
vtune: Executing actions 49 % Saving the result                                
vtune: Executing actions 50 % Saving the result                                
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              Elapsed Time: 19.149s
    CPU Time: 6.486s
        Effective Time: 3.986s
        Spin Time: 2.436s
         | A significant portion of CPU time is spent waiting. Use this metric
         | to discover which synchronizations are spinning. Consider adjusting
         | spin wait parameters, changing the lock implementation (for example,
         | by backing off then descheduling), or adjusting the synchronization
         | granularity.
         |
            Imbalance or Serial Spinning: 1.350s
             | The threading runtime function related to time spent on imbalance
             | or serial spinning consumed a significant amount of CPU time.
             | This can be caused by a load imbalance, insufficient concurrency
             | for all working threads, or busy waits of worker threads while
             | serial code is executed. If there is an imbalance, apply dynamic
             | work scheduling or reduce the size of work chunks or tasks. If
             | there is insufficient concurrency, consider collapsing the outer
             | and inner loops. If there is a wait for completion of serial
             | code, explore options for parallelization with Intel Advisor,
             | algorithm, or microarchitecture tuning of the application's
             | serial code with VTune Profiler Basic Hotspots or
             | Microarchitecture Exploration analysis respectively. For OpenMP*
             | applications, use the Per-Barrier OpenMP Potential Gain metric
             | set in the HPC Performance Characterization analysis to discover
             | the reason for high imbalance or serial spin time.
             |
            Lock Contention: 0s
            Other: 1.085s
        Overhead Time: 0.064s
            Creation: 0.012s
            Scheduling: 0s
            Reduction: 0s
            Atomics: 0s
            Other: 0.052s
    Total Thread Count: 16
    Paused Time: 18.737s

Top Hotspots
Function                                                                                                                                                                                                                                                                                                                                                                                                                                                           Module           CPU Time  % of CPU Time(%)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  ---------------  --------  ----------------
c10::function_ref<void (char**, long const*, long, long)>::callback_fn<at::native::AVX2::VectorizedLoop2d<at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(float)#1}, at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(at::vec::AVX2::Vectorized<float>)#2}>>  libtorch_cpu.so    3.986s             61.5%
__kmp_fork_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1       2.282s             35.2%
GOMP_parallel                                                                                                                                                                                                                                                                                                                                                                                                                                                      libgomp.so.1       0.178s              2.7%
__kmp_join_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1       0.028s              0.4%
[OpenMP dispatcher]                                                                                                                                                                                                                                                                                                                                                                                                                                                libgomp.so.1       0.012s              0.2%
Effective Physical Core Utilization: 53.1% (8.489 out of 16)
 | The metric value is low, which may signal a poor physical CPU cores
 | utilization caused by:
 |     - load imbalance
 |     - threading runtime overhead
 |     - contended synchronization
 |     - thread/process underutilization
 |     - incorrect affinity that utilizes logical cores instead of physical
 |       cores
 | Explore sub-metrics to estimate the efficiency of MPI and OpenMP parallelism
 | or run the Locks and Waits analysis to identify parallel bottlenecks for
 | other parallel runtimes.
 |
    Effective Logical Core Utilization: 48.9% (15.647 out of 32)
     | The metric value is low, which may signal a poor logical CPU cores
     | utilization. Consider improving physical core utilization as the first
     | step and then look at opportunities to utilize logical cores, which in
     | some cases can improve processor throughput and overall performance of
     | multi-threaded applications.
     |
Collection and Platform Info
    Application Command Line: /proj/prismgt-PG0/anaconda3/envs/torch2/bin/python "/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py" 
    Operating System: 5.4.0-164-generic DISTRIB_ID=Ubuntu DISTRIB_RELEASE=20.04 DISTRIB_CODENAME=focal DISTRIB_DESCRIPTION="Ubuntu 20.04 LTS"
    Computer Name: c4130-node.v100ubuntu20.prismgt-pg0.wisc.cloudlab.us
    Result Size: 4.6 MB 
    Collection start time: 03:32:14 02/01/2024 UTC
    Collection stop time: 03:32:34 02/01/2024 UTC
    Collector Type: Event-based counting driver,User-mode sampling and tracing
    CPU
        Name: Intel(R) Xeon(R) Processor code named Broadwell
        Frequency: 3.200 GHz
        Logical CPU Count: 32
        LLC size: 26.2 MB 
        Cache Allocation Technology
            Level 2 capability: not detected
            Level 3 capability: available

If you want to skip descriptions of detected performance issues in the report,
enter: vtune -report summary -report-knob show-issues=false -r <my_result_dir>.
Alternatively, you may view the report in the csv format: vtune -report
<report_name> -format=csv.

vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions 50 % Finalizing results                               
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              
vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
Running /mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py for run 8
vtune: Warning: Pause command is not supported for managed code profiling. Runtime overhead is still possible. Data size limit may be exceeded.
vtune: Collection paused.
EMON collector successfully paused.
vtune: Collection paused.
vtune: Collection resumed.
vtune: Collection detached.
vtune: Collection stopped.
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions  0 % Finalizing the result                            
vtune: Executing actions  0 % Clearing the database                            
vtune: Executing actions  7 % Clearing the database                            
vtune: Executing actions  7 % Loading raw data to the database                 
vtune: Executing actions  7 % Loading 'systemcollector-566904-c4130-node.v100ub
vtune: Executing actions 12 % Loading 'systemcollector-566904-c4130-node.v100ub
vtune: Executing actions 12 % Loading '566904-566909.0.trace' file             
vtune: Executing actions 12 % Loading 'userapicollector-566909-9550c2dd.trace' 
vtune: Executing actions 12 % Loading '/mydata/rbachkaniwala3/code/rajveerb-ml-
vtune: Executing actions 12 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Setting data model parameters                    
vtune: Executing actions 19 % Resolving module symbols                         
vtune: Executing actions 19 % Resolving information for dangling locations     
vtune: Executing actions 19 % Resolving information for `libc.so.6'            
vtune: Executing actions 19 % Resolving information for `libpthread.so.0'      
vtune: Executing actions 19 % Resolving information for `libgomp.so.1'         
vtune: Executing actions 19 % Resolving information for `libtpsstool.so'       
vtune: Executing actions 19 % Resolving information for `python3.10'           
vtune: Executing actions 19 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 20 % Resolving information for `libtorch_python.so'   
vtune: Warning: Cannot locate debugging information for file `/opt/intel/oneapi/vtune/2024.0/lib64/libtpsstool.so'.
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_python.so'.

vtune: Executing actions 21 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 22 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 22 % Resolving information for `libtorch_cpu.so'      
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_cpu.so'.

vtune: Executing actions 22 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving thread name information                
vtune: Executing actions 24 % Resolving thread name information                
vtune: Executing actions 24 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving interrupt name information             
vtune: Executing actions 26 % Resolving interrupt name information             
vtune: Executing actions 26 % Processing profile metrics and debug information 
vtune: Executing actions 28 % Processing profile metrics and debug information 
vtune: Executing actions 30 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Setting data model parameters                    
vtune: Executing actions 32 % Setting data model parameters                    
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 33 % Precomputing frequently used data                
vtune: Executing actions 35 % Precomputing frequently used data                
vtune: Executing actions 36 % Precomputing frequently used data                
vtune: Executing actions 38 % Precomputing frequently used data                
vtune: Executing actions 38 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Discarding redundant overtime data               
vtune: Executing actions 41 % Discarding redundant overtime data               
vtune: Executing actions 41 % Saving the result                                
vtune: Executing actions 42 % Saving the result                                
vtune: Executing actions 44 % Saving the result                                
vtune: Executing actions 49 % Saving the result                                
vtune: Executing actions 50 % Saving the result                                
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              Elapsed Time: 19.116s
    CPU Time: 8.435s
        Effective Time: 4.834s
        Spin Time: 3.562s
         | A significant portion of CPU time is spent waiting. Use this metric
         | to discover which synchronizations are spinning. Consider adjusting
         | spin wait parameters, changing the lock implementation (for example,
         | by backing off then descheduling), or adjusting the synchronization
         | granularity.
         |
            Imbalance or Serial Spinning: 2.282s
             | The threading runtime function related to time spent on imbalance
             | or serial spinning consumed a significant amount of CPU time.
             | This can be caused by a load imbalance, insufficient concurrency
             | for all working threads, or busy waits of worker threads while
             | serial code is executed. If there is an imbalance, apply dynamic
             | work scheduling or reduce the size of work chunks or tasks. If
             | there is insufficient concurrency, consider collapsing the outer
             | and inner loops. If there is a wait for completion of serial
             | code, explore options for parallelization with Intel Advisor,
             | algorithm, or microarchitecture tuning of the application's
             | serial code with VTune Profiler Basic Hotspots or
             | Microarchitecture Exploration analysis respectively. For OpenMP*
             | applications, use the Per-Barrier OpenMP Potential Gain metric
             | set in the HPC Performance Characterization analysis to discover
             | the reason for high imbalance or serial spin time.
             |
            Lock Contention: 0s
            Other: 1.280s
        Overhead Time: 0.040s
            Creation: 0s
            Scheduling: 0s
            Reduction: 0s
            Atomics: 0s
            Other: 0.040s
    Total Thread Count: 16
    Paused Time: 18.583s

Top Hotspots
Function                                                                                                                                                                                                                                                                                                                                                                                                                                                           Module           CPU Time  % of CPU Time(%)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  ---------------  --------  ----------------
c10::function_ref<void (char**, long const*, long, long)>::callback_fn<at::native::AVX2::VectorizedLoop2d<at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(float)#1}, at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(at::vec::AVX2::Vectorized<float>)#2}>>  libtorch_cpu.so    4.834s             57.3%
__kmp_fork_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1       3.188s             37.8%
GOMP_parallel                                                                                                                                                                                                                                                                                                                                                                                                                                                      libgomp.so.1       0.330s              3.9%
__kmp_join_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1       0.084s              1.0%
Effective Physical Core Utilization: 57.6% (9.219 out of 16)
 | The metric value is low, which may signal a poor physical CPU cores
 | utilization caused by:
 |     - load imbalance
 |     - threading runtime overhead
 |     - contended synchronization
 |     - thread/process underutilization
 |     - incorrect affinity that utilizes logical cores instead of physical
 |       cores
 | Explore sub-metrics to estimate the efficiency of MPI and OpenMP parallelism
 | or run the Locks and Waits analysis to identify parallel bottlenecks for
 | other parallel runtimes.
 |
    Effective Logical Core Utilization: 54.3% (17.386 out of 32)
     | The metric value is low, which may signal a poor logical CPU cores
     | utilization. Consider improving physical core utilization as the first
     | step and then look at opportunities to utilize logical cores, which in
     | some cases can improve processor throughput and overall performance of
     | multi-threaded applications.
     |
Collection and Platform Info
    Application Command Line: /proj/prismgt-PG0/anaconda3/envs/torch2/bin/python "/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py" 
    Operating System: 5.4.0-164-generic DISTRIB_ID=Ubuntu DISTRIB_RELEASE=20.04 DISTRIB_CODENAME=focal DISTRIB_DESCRIPTION="Ubuntu 20.04 LTS"
    Computer Name: c4130-node.v100ubuntu20.prismgt-pg0.wisc.cloudlab.us
    Result Size: 4.7 MB 
    Collection start time: 03:32:51 02/01/2024 UTC
    Collection stop time: 03:33:10 02/01/2024 UTC
    Collector Type: Event-based counting driver,User-mode sampling and tracing
    CPU
        Name: Intel(R) Xeon(R) Processor code named Broadwell
        Frequency: 3.200 GHz
        Logical CPU Count: 32
        LLC size: 26.2 MB 
        Cache Allocation Technology
            Level 2 capability: not detected
            Level 3 capability: available

If you want to skip descriptions of detected performance issues in the report,
enter: vtune -report summary -report-knob show-issues=false -r <my_result_dir>.
Alternatively, you may view the report in the csv format: vtune -report
<report_name> -format=csv.

vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions 50 % Finalizing results                               
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              
vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
Running /mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py for run 9
vtune: Warning: Pause command is not supported for managed code profiling. Runtime overhead is still possible. Data size limit may be exceeded.
vtune: Collection paused.
EMON collector successfully paused.
vtune: Collection paused.
vtune: Collection resumed.
vtune: Collection detached.
vtune: Collection stopped.
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions  0 % Finalizing the result                            
vtune: Executing actions  0 % Clearing the database                            
vtune: Executing actions  7 % Clearing the database                            
vtune: Executing actions  7 % Loading raw data to the database                 
vtune: Executing actions  7 % Loading 'systemcollector-567052-c4130-node.v100ub
vtune: Executing actions 12 % Loading 'systemcollector-567052-c4130-node.v100ub
vtune: Executing actions 12 % Loading '567052-567057.0.trace' file             
vtune: Executing actions 12 % Loading 'userapicollector-567057-0a608ec3.trace' 
vtune: Executing actions 12 % Loading '/mydata/rbachkaniwala3/code/rajveerb-ml-
vtune: Executing actions 12 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Setting data model parameters                    
vtune: Executing actions 19 % Resolving module symbols                         
vtune: Executing actions 19 % Resolving information for dangling locations     
vtune: Executing actions 19 % Resolving information for `ld-linux-x86-64.so.2' 
vtune: Executing actions 19 % Resolving information for `libpthread.so.0'      
vtune: Executing actions 19 % Resolving information for `libc.so.6'            
vtune: Executing actions 19 % Resolving information for `libgomp.so.1'         
vtune: Executing actions 19 % Resolving information for `libtpsstool.so'       
vtune: Executing actions 19 % Resolving information for `python3.10'           
vtune: Executing actions 20 % Resolving information for `python3.10'           
vtune: Executing actions 20 % Resolving information for `libtorch_python.so'   
vtune: Warning: Cannot locate debugging information for file `/opt/intel/oneapi/vtune/2024.0/lib64/libtpsstool.so'.
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_python.so'.

vtune: Executing actions 21 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 21 % Resolving information for `libtorch_cpu.so'      
vtune: Executing actions 22 % Resolving information for `libtorch_cpu.so'      
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_cpu.so'.

vtune: Executing actions 22 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving thread name information                
vtune: Executing actions 24 % Resolving thread name information                
vtune: Executing actions 24 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving interrupt name information             
vtune: Executing actions 26 % Resolving interrupt name information             
vtune: Executing actions 26 % Processing profile metrics and debug information 
vtune: Executing actions 28 % Processing profile metrics and debug information 
vtune: Executing actions 30 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Setting data model parameters                    
vtune: Executing actions 32 % Setting data model parameters                    
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 33 % Precomputing frequently used data                
vtune: Executing actions 35 % Precomputing frequently used data                
vtune: Executing actions 36 % Precomputing frequently used data                
vtune: Executing actions 38 % Precomputing frequently used data                
vtune: Executing actions 38 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Discarding redundant overtime data               
vtune: Executing actions 41 % Discarding redundant overtime data               
vtune: Executing actions 41 % Saving the result                                
vtune: Executing actions 42 % Saving the result                                
vtune: Executing actions 44 % Saving the result                                
vtune: Executing actions 50 % Saving the result                                
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              Elapsed Time: 19.396s
    CPU Time: 8.171s
        Effective Time: 4.634s
        Spin Time: 3.498s
         | A significant portion of CPU time is spent waiting. Use this metric
         | to discover which synchronizations are spinning. Consider adjusting
         | spin wait parameters, changing the lock implementation (for example,
         | by backing off then descheduling), or adjusting the synchronization
         | granularity.
         |
            Imbalance or Serial Spinning: 2.210s
             | The threading runtime function related to time spent on imbalance
             | or serial spinning consumed a significant amount of CPU time.
             | This can be caused by a load imbalance, insufficient concurrency
             | for all working threads, or busy waits of worker threads while
             | serial code is executed. If there is an imbalance, apply dynamic
             | work scheduling or reduce the size of work chunks or tasks. If
             | there is insufficient concurrency, consider collapsing the outer
             | and inner loops. If there is a wait for completion of serial
             | code, explore options for parallelization with Intel Advisor,
             | algorithm, or microarchitecture tuning of the application's
             | serial code with VTune Profiler Basic Hotspots or
             | Microarchitecture Exploration analysis respectively. For OpenMP*
             | applications, use the Per-Barrier OpenMP Potential Gain metric
             | set in the HPC Performance Characterization analysis to discover
             | the reason for high imbalance or serial spin time.
             |
            Lock Contention: 0s
            Other: 1.288s
        Overhead Time: 0.040s
            Creation: 0s
            Scheduling: 0s
            Reduction: 0s
            Atomics: 0s
            Other: 0.040s
    Total Thread Count: 16
    Paused Time: 18.880s

Top Hotspots
Function                                                                                                                                                                                                                                                                                                                                                                                                                                                           Module                CPU Time  % of CPU Time(%)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  --------------------  --------  ----------------
c10::function_ref<void (char**, long const*, long, long)>::callback_fn<at::native::AVX2::VectorizedLoop2d<at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(float)#1}, at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(at::vec::AVX2::Vectorized<float>)#2}>>  libtorch_cpu.so         4.622s             56.6%
__kmp_fork_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1            3.278s             40.1%
GOMP_parallel                                                                                                                                                                                                                                                                                                                                                                                                                                                      libgomp.so.1            0.224s              2.7%
__kmp_join_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1            0.036s              0.4%
__tls_get_addr                                                                                                                                                                                                                                                                                                                                                                                                                                                     ld-linux-x86-64.so.2    0.012s              0.1%
Effective Physical Core Utilization: 77.3% (12.371 out of 16)
 | The metric value is low, which may signal a poor physical CPU cores
 | utilization caused by:
 |     - load imbalance
 |     - threading runtime overhead
 |     - contended synchronization
 |     - thread/process underutilization
 |     - incorrect affinity that utilizes logical cores instead of physical
 |       cores
 | Explore sub-metrics to estimate the efficiency of MPI and OpenMP parallelism
 | or run the Locks and Waits analysis to identify parallel bottlenecks for
 | other parallel runtimes.
 |
    Effective Logical Core Utilization: 59.4% (19.018 out of 32)
     | The metric value is low, which may signal a poor logical CPU cores
     | utilization. Consider improving physical core utilization as the first
     | step and then look at opportunities to utilize logical cores, which in
     | some cases can improve processor throughput and overall performance of
     | multi-threaded applications.
     |
Collection and Platform Info
    Application Command Line: /proj/prismgt-PG0/anaconda3/envs/torch2/bin/python "/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py" 
    Operating System: 5.4.0-164-generic DISTRIB_ID=Ubuntu DISTRIB_RELEASE=20.04 DISTRIB_CODENAME=focal DISTRIB_DESCRIPTION="Ubuntu 20.04 LTS"
    Computer Name: c4130-node.v100ubuntu20.prismgt-pg0.wisc.cloudlab.us
    Result Size: 4.7 MB 
    Collection start time: 03:33:27 02/01/2024 UTC
    Collection stop time: 03:33:47 02/01/2024 UTC
    Collector Type: Event-based counting driver,User-mode sampling and tracing
    CPU
        Name: Intel(R) Xeon(R) Processor code named Broadwell
        Frequency: 3.200 GHz
        Logical CPU Count: 32
        LLC size: 26.2 MB 
        Cache Allocation Technology
            Level 2 capability: not detected
            Level 3 capability: available

If you want to skip descriptions of detected performance issues in the report,
enter: vtune -report summary -report-knob show-issues=false -r <my_result_dir>.
Alternatively, you may view the report in the csv format: vtune -report
<report_name> -format=csv.

vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions 50 % Finalizing results                               
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              
vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
Running /mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py for run 10
vtune: Warning: Pause command is not supported for managed code profiling. Runtime overhead is still possible. Data size limit may be exceeded.
vtune: Collection paused.
EMON collector successfully paused.
vtune: Collection paused.
vtune: Collection resumed.
vtune: Collection detached.
vtune: Collection stopped.
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions  0 % Finalizing the result                            
vtune: Executing actions  0 % Clearing the database                            
vtune: Executing actions  7 % Clearing the database                            
vtune: Executing actions  7 % Loading raw data to the database                 
vtune: Executing actions  7 % Loading 'systemcollector-567204-c4130-node.v100ub
vtune: Executing actions 12 % Loading 'systemcollector-567204-c4130-node.v100ub
vtune: Executing actions 12 % Loading '567204-567209.0.trace' file             
vtune: Executing actions 12 % Loading 'userapicollector-567209-7a353d77.trace' 
vtune: Executing actions 12 % Loading '/mydata/rbachkaniwala3/code/rajveerb-ml-
vtune: Executing actions 12 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Setting data model parameters                    
vtune: Executing actions 19 % Resolving module symbols                         
vtune: Executing actions 19 % Resolving information for dangling locations     
vtune: Executing actions 19 % Resolving information for `libc.so.6'            
vtune: Executing actions 19 % Resolving information for `libpthread.so.0'      
vtune: Executing actions 19 % Resolving information for `libgomp.so.1'         
vtune: Executing actions 19 % Resolving information for `libtpsstool.so'       
vtune: Executing actions 19 % Resolving information for `python3.10'           
vtune: Executing actions 19 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 20 % Resolving information for `libtorch_python.so'   
vtune: Warning: Cannot locate debugging information for file `/opt/intel/oneapi/vtune/2024.0/lib64/libtpsstool.so'.
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_python.so'.

vtune: Executing actions 21 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 22 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 22 % Resolving information for `libtorch_cpu.so'      
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_cpu.so'.

vtune: Executing actions 22 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving thread name information                
vtune: Executing actions 24 % Resolving thread name information                
vtune: Executing actions 24 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving interrupt name information             
vtune: Executing actions 26 % Resolving interrupt name information             
vtune: Executing actions 26 % Processing profile metrics and debug information 
vtune: Executing actions 28 % Processing profile metrics and debug information 
vtune: Executing actions 30 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Setting data model parameters                    
vtune: Executing actions 32 % Setting data model parameters                    
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 33 % Precomputing frequently used data                
vtune: Executing actions 35 % Precomputing frequently used data                
vtune: Executing actions 36 % Precomputing frequently used data                
vtune: Executing actions 38 % Precomputing frequently used data                
vtune: Executing actions 38 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Discarding redundant overtime data               
vtune: Executing actions 41 % Discarding redundant overtime data               
vtune: Executing actions 41 % Saving the result                                
vtune: Executing actions 42 % Saving the result                                
vtune: Executing actions 44 % Saving the result                                
vtune: Executing actions 50 % Saving the result                                
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              Elapsed Time: 18.768s
    CPU Time: 7.013s
        Effective Time: 4.142s
        Spin Time: 2.839s
         | A significant portion of CPU time is spent waiting. Use this metric
         | to discover which synchronizations are spinning. Consider adjusting
         | spin wait parameters, changing the lock implementation (for example,
         | by backing off then descheduling), or adjusting the synchronization
         | granularity.
         |
            Imbalance or Serial Spinning: 1.619s
             | The threading runtime function related to time spent on imbalance
             | or serial spinning consumed a significant amount of CPU time.
             | This can be caused by a load imbalance, insufficient concurrency
             | for all working threads, or busy waits of worker threads while
             | serial code is executed. If there is an imbalance, apply dynamic
             | work scheduling or reduce the size of work chunks or tasks. If
             | there is insufficient concurrency, consider collapsing the outer
             | and inner loops. If there is a wait for completion of serial
             | code, explore options for parallelization with Intel Advisor,
             | algorithm, or microarchitecture tuning of the application's
             | serial code with VTune Profiler Basic Hotspots or
             | Microarchitecture Exploration analysis respectively. For OpenMP*
             | applications, use the Per-Barrier OpenMP Potential Gain metric
             | set in the HPC Performance Characterization analysis to discover
             | the reason for high imbalance or serial spin time.
             |
            Lock Contention: 0s
            Other: 1.220s
        Overhead Time: 0.032s
            Creation: 0s
            Scheduling: 0s
            Reduction: 0s
            Atomics: 0s
            Other: 0.032s
    Total Thread Count: 16
    Paused Time: 18.322s

Top Hotspots
Function                                                                                                                                                                                                                                                                                                                                                                                                                                                           Module           CPU Time  % of CPU Time(%)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  ---------------  --------  ----------------
c10::function_ref<void (char**, long const*, long, long)>::callback_fn<at::native::AVX2::VectorizedLoop2d<at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(float)#1}, at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(at::vec::AVX2::Vectorized<float>)#2}>>  libtorch_cpu.so    4.142s             59.1%
__kmp_fork_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1       2.431s             34.7%
GOMP_parallel                                                                                                                                                                                                                                                                                                                                                                                                                                                      libgomp.so.1       0.228s              3.3%
__kmp_join_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1       0.212s              3.0%
pymalloc_alloc                                                                                                                                                                                                                                                                                                                                                                                                                                                     python3.10         0.000s              0.0%
Effective Physical Core Utilization: 60.1% (9.622 out of 16)
 | The metric value is low, which may signal a poor physical CPU cores
 | utilization caused by:
 |     - load imbalance
 |     - threading runtime overhead
 |     - contended synchronization
 |     - thread/process underutilization
 |     - incorrect affinity that utilizes logical cores instead of physical
 |       cores
 | Explore sub-metrics to estimate the efficiency of MPI and OpenMP parallelism
 | or run the Locks and Waits analysis to identify parallel bottlenecks for
 | other parallel runtimes.
 |
    Effective Logical Core Utilization: 53.9% (17.252 out of 32)
     | The metric value is low, which may signal a poor logical CPU cores
     | utilization. Consider improving physical core utilization as the first
     | step and then look at opportunities to utilize logical cores, which in
     | some cases can improve processor throughput and overall performance of
     | multi-threaded applications.
     |
Collection and Platform Info
    Application Command Line: /proj/prismgt-PG0/anaconda3/envs/torch2/bin/python "/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py" 
    Operating System: 5.4.0-164-generic DISTRIB_ID=Ubuntu DISTRIB_RELEASE=20.04 DISTRIB_CODENAME=focal DISTRIB_DESCRIPTION="Ubuntu 20.04 LTS"
    Computer Name: c4130-node.v100ubuntu20.prismgt-pg0.wisc.cloudlab.us
    Result Size: 4.7 MB 
    Collection start time: 03:34:03 02/01/2024 UTC
    Collection stop time: 03:34:22 02/01/2024 UTC
    Collector Type: Event-based counting driver,User-mode sampling and tracing
    CPU
        Name: Intel(R) Xeon(R) Processor code named Broadwell
        Frequency: 3.200 GHz
        Logical CPU Count: 32
        LLC size: 26.2 MB 
        Cache Allocation Technology
            Level 2 capability: not detected
            Level 3 capability: available

If you want to skip descriptions of detected performance issues in the report,
enter: vtune -report summary -report-knob show-issues=false -r <my_result_dir>.
Alternatively, you may view the report in the csv format: vtune -report
<report_name> -format=csv.

vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions 50 % Finalizing results                               
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              
vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
Running /mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py for run 11
vtune: Warning: Pause command is not supported for managed code profiling. Runtime overhead is still possible. Data size limit may be exceeded.
vtune: Collection paused.
EMON collector successfully paused.
vtune: Collection paused.
vtune: Collection resumed.
vtune: Collection detached.
vtune: Collection stopped.
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions  0 % Finalizing the result                            
vtune: Executing actions  0 % Clearing the database                            
vtune: Executing actions  7 % Clearing the database                            
vtune: Executing actions  7 % Loading raw data to the database                 
vtune: Executing actions  7 % Loading 'systemcollector-567330-c4130-node.v100ub
vtune: Executing actions 12 % Loading 'systemcollector-567330-c4130-node.v100ub
vtune: Executing actions 12 % Loading '567330-567335.0.trace' file             
vtune: Executing actions 12 % Loading 'userapicollector-567335-b104baf0.trace' 
vtune: Executing actions 12 % Loading '/mydata/rbachkaniwala3/code/rajveerb-ml-
vtune: Executing actions 12 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Setting data model parameters                    
vtune: Executing actions 19 % Resolving module symbols                         
vtune: Executing actions 19 % Resolving information for dangling locations     
vtune: Executing actions 19 % Resolving information for `libc.so.6'            
vtune: Executing actions 19 % Resolving information for `ld-linux-x86-64.so.2' 
vtune: Executing actions 19 % Resolving information for `libpthread.so.0'      
vtune: Executing actions 19 % Resolving information for `libgomp.so.1'         
vtune: Executing actions 19 % Resolving information for `itt.cpython-310-x86_64
vtune: Executing actions 20 % Resolving information for `itt.cpython-310-x86_64
vtune: Executing actions 20 % Resolving information for `libc-dynamic.so'      
vtune: Executing actions 20 % Resolving information for `python3.10'           
vtune: Executing actions 20 % Resolving information for `libtpsstool.so'       
vtune: Executing actions 21 % Resolving information for `libtpsstool.so'       
vtune: Executing actions 21 % Resolving information for `libtorch_python.so'   
vtune: Warning: Cannot locate debugging information for file `/opt/intel/oneapi/vtune/2024.0/lib64/libtpsstool.so'.
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_python.so'.

vtune: Executing actions 21 % Resolving information for `libtorch_cpu.so'      
vtune: Executing actions 22 % Resolving information for `libtorch_cpu.so'      
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_cpu.so'.

vtune: Executing actions 22 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving thread name information                
vtune: Executing actions 24 % Resolving thread name information                
vtune: Executing actions 24 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving interrupt name information             
vtune: Executing actions 26 % Resolving interrupt name information             
vtune: Executing actions 26 % Processing profile metrics and debug information 
vtune: Executing actions 28 % Processing profile metrics and debug information 
vtune: Executing actions 30 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Setting data model parameters                    
vtune: Executing actions 32 % Setting data model parameters                    
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 33 % Precomputing frequently used data                
vtune: Executing actions 35 % Precomputing frequently used data                
vtune: Executing actions 36 % Precomputing frequently used data                
vtune: Executing actions 38 % Precomputing frequently used data                
vtune: Executing actions 38 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Discarding redundant overtime data               
vtune: Executing actions 41 % Discarding redundant overtime data               
vtune: Executing actions 41 % Saving the result                                
vtune: Executing actions 42 % Saving the result                                
vtune: Executing actions 44 % Saving the result                                
vtune: Executing actions 50 % Saving the result                                
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              Elapsed Time: 16.553s
    CPU Time: 5.171s
        Effective Time: 3.252s
        Spin Time: 1.871s
         | A significant portion of CPU time is spent waiting. Use this metric
         | to discover which synchronizations are spinning. Consider adjusting
         | spin wait parameters, changing the lock implementation (for example,
         | by backing off then descheduling), or adjusting the synchronization
         | granularity.
         |
            Imbalance or Serial Spinning: 0.978s
             | The threading runtime function related to time spent on imbalance
             | or serial spinning consumed a significant amount of CPU time.
             | This can be caused by a load imbalance, insufficient concurrency
             | for all working threads, or busy waits of worker threads while
             | serial code is executed. If there is an imbalance, apply dynamic
             | work scheduling or reduce the size of work chunks or tasks. If
             | there is insufficient concurrency, consider collapsing the outer
             | and inner loops. If there is a wait for completion of serial
             | code, explore options for parallelization with Intel Advisor,
             | algorithm, or microarchitecture tuning of the application's
             | serial code with VTune Profiler Basic Hotspots or
             | Microarchitecture Exploration analysis respectively. For OpenMP*
             | applications, use the Per-Barrier OpenMP Potential Gain metric
             | set in the HPC Performance Characterization analysis to discover
             | the reason for high imbalance or serial spin time.
             |
            Lock Contention: 0s
            Other: 0.894s
        Overhead Time: 0.048s
            Creation: 0s
            Scheduling: 0s
            Reduction: 0s
            Atomics: 0s
            Other: 0.048s
    Total Thread Count: 16
    Paused Time: 16.226s

Top Hotspots
Function                                                                                                                                                                                                                                                                                                                                                                                                                                                           Module                CPU Time  % of CPU Time(%)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  --------------------  --------  ----------------
c10::function_ref<void (char**, long const*, long, long)>::callback_fn<at::native::AVX2::VectorizedLoop2d<at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(float)#1}, at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(at::vec::AVX2::Vectorized<float>)#2}>>  libtorch_cpu.so         3.236s             62.6%
__kmp_fork_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1            1.815s             35.1%
GOMP_parallel                                                                                                                                                                                                                                                                                                                                                                                                                                                      libgomp.so.1            0.092s              1.8%
__kmp_join_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1            0.012s              0.2%
__tls_get_addr                                                                                                                                                                                                                                                                                                                                                                                                                                                     ld-linux-x86-64.so.2    0.008s              0.2%
OS_BARESYSCALL_DoCallAsmIntel64Linux                                                                                                                                                                                                                                                                                                                                                                                                                               libc-dynamic.so         0.008s              0.2%
Effective Physical Core Utilization: 51.9% (8.301 out of 16)
 | The metric value is low, which may signal a poor physical CPU cores
 | utilization caused by:
 |     - load imbalance
 |     - threading runtime overhead
 |     - contended synchronization
 |     - thread/process underutilization
 |     - incorrect affinity that utilizes logical cores instead of physical
 |       cores
 | Explore sub-metrics to estimate the efficiency of MPI and OpenMP parallelism
 | or run the Locks and Waits analysis to identify parallel bottlenecks for
 | other parallel runtimes.
 |
    Effective Logical Core Utilization: 49.0% (15.677 out of 32)
     | The metric value is low, which may signal a poor logical CPU cores
     | utilization. Consider improving physical core utilization as the first
     | step and then look at opportunities to utilize logical cores, which in
     | some cases can improve processor throughput and overall performance of
     | multi-threaded applications.
     |
Collection and Platform Info
    Application Command Line: /proj/prismgt-PG0/anaconda3/envs/torch2/bin/python "/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py" 
    Operating System: 5.4.0-164-generic DISTRIB_ID=Ubuntu DISTRIB_RELEASE=20.04 DISTRIB_CODENAME=focal DISTRIB_DESCRIPTION="Ubuntu 20.04 LTS"
    Computer Name: c4130-node.v100ubuntu20.prismgt-pg0.wisc.cloudlab.us
    Result Size: 4.6 MB 
    Collection start time: 03:34:39 02/01/2024 UTC
    Collection stop time: 03:34:55 02/01/2024 UTC
    Collector Type: Event-based counting driver,User-mode sampling and tracing
    CPU
        Name: Intel(R) Xeon(R) Processor code named Broadwell
        Frequency: 3.200 GHz
        Logical CPU Count: 32
        LLC size: 26.2 MB 
        Cache Allocation Technology
            Level 2 capability: not detected
            Level 3 capability: available

If you want to skip descriptions of detected performance issues in the report,
enter: vtune -report summary -report-knob show-issues=false -r <my_result_dir>.
Alternatively, you may view the report in the csv format: vtune -report
<report_name> -format=csv.

vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions 50 % Finalizing results                               
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              
vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
Running /mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py for run 12
vtune: Warning: Pause command is not supported for managed code profiling. Runtime overhead is still possible. Data size limit may be exceeded.
vtune: Collection paused.
EMON collector successfully paused.
vtune: Collection paused.
vtune: Collection resumed.
vtune: Collection detached.
vtune: Collection stopped.
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions  0 % Finalizing the result                            
vtune: Executing actions  0 % Clearing the database                            
vtune: Executing actions  7 % Clearing the database                            
vtune: Executing actions  7 % Loading raw data to the database                 
vtune: Executing actions  7 % Loading 'systemcollector-567471-c4130-node.v100ub
vtune: Executing actions 12 % Loading 'systemcollector-567471-c4130-node.v100ub
vtune: Executing actions 12 % Loading '567471-567476.0.trace' file             
vtune: Executing actions 12 % Loading 'userapicollector-567476-4449c06f.trace' 
vtune: Executing actions 12 % Loading '/mydata/rbachkaniwala3/code/rajveerb-ml-
vtune: Executing actions 12 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Setting data model parameters                    
vtune: Executing actions 19 % Resolving module symbols                         
vtune: Executing actions 19 % Resolving information for dangling locations     
vtune: Executing actions 19 % Resolving information for `libc.so.6'            
vtune: Executing actions 19 % Resolving information for `libgomp.so.1'         
vtune: Executing actions 19 % Resolving information for `libpthread.so.0'      
vtune: Executing actions 19 % Resolving information for `libtpsstool.so'       
vtune: Executing actions 19 % Resolving information for `python3.10'           
vtune: Executing actions 19 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 20 % Resolving information for `libtorch_python.so'   
vtune: Warning: Cannot locate debugging information for file `/opt/intel/oneapi/vtune/2024.0/lib64/libtpsstool.so'.
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_python.so'.

vtune: Executing actions 21 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 22 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 22 % Resolving information for `libtorch_cpu.so'      
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_cpu.so'.

vtune: Executing actions 22 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving thread name information                
vtune: Executing actions 24 % Resolving thread name information                
vtune: Executing actions 24 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving interrupt name information             
vtune: Executing actions 26 % Resolving interrupt name information             
vtune: Executing actions 26 % Processing profile metrics and debug information 
vtune: Executing actions 28 % Processing profile metrics and debug information 
vtune: Executing actions 30 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Setting data model parameters                    
vtune: Executing actions 32 % Setting data model parameters                    
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 33 % Precomputing frequently used data                
vtune: Executing actions 35 % Precomputing frequently used data                
vtune: Executing actions 36 % Precomputing frequently used data                
vtune: Executing actions 38 % Precomputing frequently used data                
vtune: Executing actions 38 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Discarding redundant overtime data               
vtune: Executing actions 41 % Discarding redundant overtime data               
vtune: Executing actions 41 % Saving the result                                
vtune: Executing actions 42 % Saving the result                                
vtune: Executing actions 44 % Saving the result                                
vtune: Executing actions 50 % Saving the result                                
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              Elapsed Time: 18.936s
    CPU Time: 6.251s
        Effective Time: 4.377s
        Spin Time: 1.862s
         | A significant portion of CPU time is spent waiting. Use this metric
         | to discover which synchronizations are spinning. Consider adjusting
         | spin wait parameters, changing the lock implementation (for example,
         | by backing off then descheduling), or adjusting the synchronization
         | granularity.
         |
            Imbalance or Serial Spinning: 1.076s
             | The threading runtime function related to time spent on imbalance
             | or serial spinning consumed a significant amount of CPU time.
             | This can be caused by a load imbalance, insufficient concurrency
             | for all working threads, or busy waits of worker threads while
             | serial code is executed. If there is an imbalance, apply dynamic
             | work scheduling or reduce the size of work chunks or tasks. If
             | there is insufficient concurrency, consider collapsing the outer
             | and inner loops. If there is a wait for completion of serial
             | code, explore options for parallelization with Intel Advisor,
             | algorithm, or microarchitecture tuning of the application's
             | serial code with VTune Profiler Basic Hotspots or
             | Microarchitecture Exploration analysis respectively. For OpenMP*
             | applications, use the Per-Barrier OpenMP Potential Gain metric
             | set in the HPC Performance Characterization analysis to discover
             | the reason for high imbalance or serial spin time.
             |
            Lock Contention: 0s
            Other: 0.786s
        Overhead Time: 0.012s
            Creation: 0s
            Scheduling: 0s
            Reduction: 0s
            Atomics: 0s
            Other: 0.012s
    Total Thread Count: 16
    Paused Time: 18.539s

Top Hotspots
Function                                                                                                                                                                                                                                                                                                                                                                                                                                                           Module           CPU Time  % of CPU Time(%)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  ---------------  --------  ----------------
c10::function_ref<void (char**, long const*, long, long)>::callback_fn<at::native::AVX2::VectorizedLoop2d<at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(float)#1}, at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(at::vec::AVX2::Vectorized<float>)#2}>>  libtorch_cpu.so    4.377s             70.0%
__kmp_fork_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1       1.676s             26.8%
GOMP_parallel                                                                                                                                                                                                                                                                                                                                                                                                                                                      libgomp.so.1       0.162s              2.6%
__kmp_join_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1       0.024s              0.4%
__kmp_finish_implicit_task                                                                                                                                                                                                                                                                                                                                                                                                                                         libgomp.so.1       0.012s              0.2%
Effective Physical Core Utilization: 66.5% (10.644 out of 16)
 | The metric value is low, which may signal a poor physical CPU cores
 | utilization caused by:
 |     - load imbalance
 |     - threading runtime overhead
 |     - contended synchronization
 |     - thread/process underutilization
 |     - incorrect affinity that utilizes logical cores instead of physical
 |       cores
 | Explore sub-metrics to estimate the efficiency of MPI and OpenMP parallelism
 | or run the Locks and Waits analysis to identify parallel bottlenecks for
 | other parallel runtimes.
 |
    Effective Logical Core Utilization: 60.6% (19.392 out of 32)
     | The metric value is low, which may signal a poor logical CPU cores
     | utilization. Consider improving physical core utilization as the first
     | step and then look at opportunities to utilize logical cores, which in
     | some cases can improve processor throughput and overall performance of
     | multi-threaded applications.
     |
Collection and Platform Info
    Application Command Line: /proj/prismgt-PG0/anaconda3/envs/torch2/bin/python "/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py" 
    Operating System: 5.4.0-164-generic DISTRIB_ID=Ubuntu DISTRIB_RELEASE=20.04 DISTRIB_CODENAME=focal DISTRIB_DESCRIPTION="Ubuntu 20.04 LTS"
    Computer Name: c4130-node.v100ubuntu20.prismgt-pg0.wisc.cloudlab.us
    Result Size: 4.6 MB 
    Collection start time: 03:35:11 02/01/2024 UTC
    Collection stop time: 03:35:30 02/01/2024 UTC
    Collector Type: Event-based counting driver,User-mode sampling and tracing
    CPU
        Name: Intel(R) Xeon(R) Processor code named Broadwell
        Frequency: 3.200 GHz
        Logical CPU Count: 32
        LLC size: 26.2 MB 
        Cache Allocation Technology
            Level 2 capability: not detected
            Level 3 capability: available

If you want to skip descriptions of detected performance issues in the report,
enter: vtune -report summary -report-knob show-issues=false -r <my_result_dir>.
Alternatively, you may view the report in the csv format: vtune -report
<report_name> -format=csv.

vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions 50 % Finalizing results                               
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              
vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
Running /mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py for run 13
vtune: Warning: Pause command is not supported for managed code profiling. Runtime overhead is still possible. Data size limit may be exceeded.
vtune: Collection paused.
EMON collector successfully paused.
vtune: Collection paused.
vtune: Collection resumed.
vtune: Collection detached.
vtune: Collection stopped.
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions  0 % Finalizing the result                            
vtune: Executing actions  0 % Clearing the database                            
vtune: Executing actions  7 % Clearing the database                            
vtune: Executing actions  7 % Loading raw data to the database                 
vtune: Executing actions  7 % Loading 'systemcollector-567610-c4130-node.v100ub
vtune: Executing actions 12 % Loading 'systemcollector-567610-c4130-node.v100ub
vtune: Executing actions 12 % Loading '567610-567615.0.trace' file             
vtune: Executing actions 12 % Loading 'userapicollector-567615-a14a196b.trace' 
vtune: Executing actions 12 % Loading '/mydata/rbachkaniwala3/code/rajveerb-ml-
vtune: Executing actions 12 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Setting data model parameters                    
vtune: Executing actions 19 % Resolving module symbols                         
vtune: Executing actions 19 % Resolving information for dangling locations     
vtune: Executing actions 19 % Resolving information for `libc.so.6'            
vtune: Executing actions 19 % Resolving information for `libgomp.so.1'         
vtune: Executing actions 19 % Resolving information for `libpthread.so.0'      
vtune: Executing actions 19 % Resolving information for `libtpsstool.so'       
vtune: Executing actions 19 % Resolving information for `python3.10'           
vtune: Executing actions 19 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 20 % Resolving information for `libtorch_python.so'   
vtune: Warning: Cannot locate debugging information for file `/opt/intel/oneapi/vtune/2024.0/lib64/libtpsstool.so'.
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_python.so'.

vtune: Executing actions 21 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 22 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 22 % Resolving information for `libtorch_cpu.so'      
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_cpu.so'.

vtune: Executing actions 22 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving thread name information                
vtune: Executing actions 24 % Resolving thread name information                
vtune: Executing actions 24 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving interrupt name information             
vtune: Executing actions 26 % Resolving interrupt name information             
vtune: Executing actions 26 % Processing profile metrics and debug information 
vtune: Executing actions 28 % Processing profile metrics and debug information 
vtune: Executing actions 30 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Setting data model parameters                    
vtune: Executing actions 32 % Setting data model parameters                    
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 33 % Precomputing frequently used data                
vtune: Executing actions 35 % Precomputing frequently used data                
vtune: Executing actions 36 % Precomputing frequently used data                
vtune: Executing actions 38 % Precomputing frequently used data                
vtune: Executing actions 38 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Discarding redundant overtime data               
vtune: Executing actions 41 % Discarding redundant overtime data               
vtune: Executing actions 41 % Saving the result                                
vtune: Executing actions 42 % Saving the result                                
vtune: Executing actions 44 % Saving the result                                
vtune: Executing actions 49 % Saving the result                                
vtune: Executing actions 50 % Saving the result                                
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              Elapsed Time: 19.268s
    CPU Time: 7.906s
        Effective Time: 4.242s
        Spin Time: 3.584s
         | A significant portion of CPU time is spent waiting. Use this metric
         | to discover which synchronizations are spinning. Consider adjusting
         | spin wait parameters, changing the lock implementation (for example,
         | by backing off then descheduling), or adjusting the synchronization
         | granularity.
         |
            Imbalance or Serial Spinning: 2.116s
             | The threading runtime function related to time spent on imbalance
             | or serial spinning consumed a significant amount of CPU time.
             | This can be caused by a load imbalance, insufficient concurrency
             | for all working threads, or busy waits of worker threads while
             | serial code is executed. If there is an imbalance, apply dynamic
             | work scheduling or reduce the size of work chunks or tasks. If
             | there is insufficient concurrency, consider collapsing the outer
             | and inner loops. If there is a wait for completion of serial
             | code, explore options for parallelization with Intel Advisor,
             | algorithm, or microarchitecture tuning of the application's
             | serial code with VTune Profiler Basic Hotspots or
             | Microarchitecture Exploration analysis respectively. For OpenMP*
             | applications, use the Per-Barrier OpenMP Potential Gain metric
             | set in the HPC Performance Characterization analysis to discover
             | the reason for high imbalance or serial spin time.
             |
            Lock Contention: 0s
            Other: 1.468s
        Overhead Time: 0.080s
            Creation: 0.008s
            Scheduling: 0s
            Reduction: 0s
            Atomics: 0s
            Other: 0.072s
    Total Thread Count: 16
    Paused Time: 18.765s

Top Hotspots
Function                                                                                                                                                                                                                                                                                                                                                                                                                                                           Module           CPU Time  % of CPU Time(%)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  ---------------  --------  ----------------
c10::function_ref<void (char**, long const*, long, long)>::callback_fn<at::native::AVX2::VectorizedLoop2d<at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(float)#1}, at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(at::vec::AVX2::Vectorized<float>)#2}>>  libtorch_cpu.so    4.242s             53.7%
__kmp_fork_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1       3.076s             38.9%
__kmp_join_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1       0.292s              3.7%
GOMP_parallel                                                                                                                                                                                                                                                                                                                                                                                                                                                      libgomp.so.1       0.288s              3.6%
[OpenMP dispatcher]                                                                                                                                                                                                                                                                                                                                                                                                                                                libgomp.so.1       0.008s              0.1%
Effective Physical Core Utilization: 54.0% (8.648 out of 16)
 | The metric value is low, which may signal a poor physical CPU cores
 | utilization caused by:
 |     - load imbalance
 |     - threading runtime overhead
 |     - contended synchronization
 |     - thread/process underutilization
 |     - incorrect affinity that utilizes logical cores instead of physical
 |       cores
 | Explore sub-metrics to estimate the efficiency of MPI and OpenMP parallelism
 | or run the Locks and Waits analysis to identify parallel bottlenecks for
 | other parallel runtimes.
 |
    Effective Logical Core Utilization: 49.8% (15.934 out of 32)
     | The metric value is low, which may signal a poor logical CPU cores
     | utilization. Consider improving physical core utilization as the first
     | step and then look at opportunities to utilize logical cores, which in
     | some cases can improve processor throughput and overall performance of
     | multi-threaded applications.
     |
Collection and Platform Info
    Application Command Line: /proj/prismgt-PG0/anaconda3/envs/torch2/bin/python "/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py" 
    Operating System: 5.4.0-164-generic DISTRIB_ID=Ubuntu DISTRIB_RELEASE=20.04 DISTRIB_CODENAME=focal DISTRIB_DESCRIPTION="Ubuntu 20.04 LTS"
    Computer Name: c4130-node.v100ubuntu20.prismgt-pg0.wisc.cloudlab.us
    Result Size: 4.7 MB 
    Collection start time: 03:35:47 02/01/2024 UTC
    Collection stop time: 03:36:06 02/01/2024 UTC
    Collector Type: Event-based counting driver,User-mode sampling and tracing
    CPU
        Name: Intel(R) Xeon(R) Processor code named Broadwell
        Frequency: 3.200 GHz
        Logical CPU Count: 32
        LLC size: 26.2 MB 
        Cache Allocation Technology
            Level 2 capability: not detected
            Level 3 capability: available

If you want to skip descriptions of detected performance issues in the report,
enter: vtune -report summary -report-knob show-issues=false -r <my_result_dir>.
Alternatively, you may view the report in the csv format: vtune -report
<report_name> -format=csv.

vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions 50 % Finalizing results                               
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              
vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
Running /mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py for run 14
vtune: Warning: Pause command is not supported for managed code profiling. Runtime overhead is still possible. Data size limit may be exceeded.
vtune: Collection paused.
EMON collector successfully paused.
vtune: Collection paused.
vtune: Collection resumed.
vtune: Collection detached.
vtune: Collection stopped.
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions  0 % Finalizing the result                            
vtune: Executing actions  0 % Clearing the database                            
vtune: Executing actions  7 % Clearing the database                            
vtune: Executing actions  7 % Loading raw data to the database                 
vtune: Executing actions  7 % Loading 'systemcollector-567767-c4130-node.v100ub
vtune: Executing actions 12 % Loading 'systemcollector-567767-c4130-node.v100ub
vtune: Executing actions 12 % Loading '567767-567772.0.trace' file             
vtune: Executing actions 12 % Loading 'userapicollector-567772-0e740c66.trace' 
vtune: Executing actions 12 % Loading '/mydata/rbachkaniwala3/code/rajveerb-ml-
vtune: Executing actions 12 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Setting data model parameters                    
vtune: Executing actions 19 % Resolving module symbols                         
vtune: Executing actions 19 % Resolving information for dangling locations     
vtune: Executing actions 19 % Resolving information for `libc.so.6'            
vtune: Executing actions 19 % Resolving information for `libpthread.so.0'      
vtune: Executing actions 19 % Resolving information for `libgomp.so.1'         
vtune: Executing actions 19 % Resolving information for `libtpsstool.so'       
vtune: Executing actions 19 % Resolving information for `python3.10'           
vtune: Executing actions 20 % Resolving information for `python3.10'           
vtune: Executing actions 20 % Resolving information for `libtorch_python.so'   
vtune: Warning: Cannot locate debugging information for file `/opt/intel/oneapi/vtune/2024.0/lib64/libtpsstool.so'.
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_python.so'.

vtune: Executing actions 21 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 22 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 22 % Resolving information for `libtorch_cpu.so'      
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_cpu.so'.

vtune: Executing actions 22 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving thread name information                
vtune: Executing actions 24 % Resolving thread name information                
vtune: Executing actions 24 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving interrupt name information             
vtune: Executing actions 26 % Resolving interrupt name information             
vtune: Executing actions 26 % Processing profile metrics and debug information 
vtune: Executing actions 28 % Processing profile metrics and debug information 
vtune: Executing actions 30 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Setting data model parameters                    
vtune: Executing actions 32 % Setting data model parameters                    
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 33 % Precomputing frequently used data                
vtune: Executing actions 35 % Precomputing frequently used data                
vtune: Executing actions 36 % Precomputing frequently used data                
vtune: Executing actions 38 % Precomputing frequently used data                
vtune: Executing actions 38 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Discarding redundant overtime data               
vtune: Executing actions 41 % Discarding redundant overtime data               
vtune: Executing actions 41 % Saving the result                                
vtune: Executing actions 42 % Saving the result                                
vtune: Executing actions 44 % Saving the result                                
vtune: Executing actions 50 % Saving the result                                
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              Elapsed Time: 18.829s
    CPU Time: 5.499s
        Effective Time: 3.853s
        Spin Time: 1.630s
         | A significant portion of CPU time is spent waiting. Use this metric
         | to discover which synchronizations are spinning. Consider adjusting
         | spin wait parameters, changing the lock implementation (for example,
         | by backing off then descheduling), or adjusting the synchronization
         | granularity.
         |
            Imbalance or Serial Spinning: 1.043s
             | The threading runtime function related to time spent on imbalance
             | or serial spinning consumed a significant amount of CPU time.
             | This can be caused by a load imbalance, insufficient concurrency
             | for all working threads, or busy waits of worker threads while
             | serial code is executed. If there is an imbalance, apply dynamic
             | work scheduling or reduce the size of work chunks or tasks. If
             | there is insufficient concurrency, consider collapsing the outer
             | and inner loops. If there is a wait for completion of serial
             | code, explore options for parallelization with Intel Advisor,
             | algorithm, or microarchitecture tuning of the application's
             | serial code with VTune Profiler Basic Hotspots or
             | Microarchitecture Exploration analysis respectively. For OpenMP*
             | applications, use the Per-Barrier OpenMP Potential Gain metric
             | set in the HPC Performance Characterization analysis to discover
             | the reason for high imbalance or serial spin time.
             |
            Lock Contention: 0s
            Other: 0.587s
        Overhead Time: 0.016s
            Creation: 0s
            Scheduling: 0s
            Reduction: 0s
            Atomics: 0s
            Other: 0.016s
    Total Thread Count: 16
    Paused Time: 18.480s

Top Hotspots
Function                                                                                                                                                                                                                                                                                                                                                                                                                                                           Module           CPU Time  % of CPU Time(%)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  ---------------  --------  ----------------
c10::function_ref<void (char**, long const*, long, long)>::callback_fn<at::native::AVX2::VectorizedLoop2d<at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(float)#1}, at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(at::vec::AVX2::Vectorized<float>)#2}>>  libtorch_cpu.so    3.853s             70.1%
__kmp_fork_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1       1.407s             25.6%
GOMP_parallel                                                                                                                                                                                                                                                                                                                                                                                                                                                      libgomp.so.1       0.156s              2.8%
__kmp_join_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1       0.083s              1.5%
Effective Physical Core Utilization: 56.5% (9.039 out of 16)
 | The metric value is low, which may signal a poor physical CPU cores
 | utilization caused by:
 |     - load imbalance
 |     - threading runtime overhead
 |     - contended synchronization
 |     - thread/process underutilization
 |     - incorrect affinity that utilizes logical cores instead of physical
 |       cores
 | Explore sub-metrics to estimate the efficiency of MPI and OpenMP parallelism
 | or run the Locks and Waits analysis to identify parallel bottlenecks for
 | other parallel runtimes.
 |
    Effective Logical Core Utilization: 48.0% (15.359 out of 32)
     | The metric value is low, which may signal a poor logical CPU cores
     | utilization. Consider improving physical core utilization as the first
     | step and then look at opportunities to utilize logical cores, which in
     | some cases can improve processor throughput and overall performance of
     | multi-threaded applications.
     |
Collection and Platform Info
    Application Command Line: /proj/prismgt-PG0/anaconda3/envs/torch2/bin/python "/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py" 
    Operating System: 5.4.0-164-generic DISTRIB_ID=Ubuntu DISTRIB_RELEASE=20.04 DISTRIB_CODENAME=focal DISTRIB_DESCRIPTION="Ubuntu 20.04 LTS"
    Computer Name: c4130-node.v100ubuntu20.prismgt-pg0.wisc.cloudlab.us
    Result Size: 4.6 MB 
    Collection start time: 03:36:23 02/01/2024 UTC
    Collection stop time: 03:36:42 02/01/2024 UTC
    Collector Type: Event-based counting driver,User-mode sampling and tracing
    CPU
        Name: Intel(R) Xeon(R) Processor code named Broadwell
        Frequency: 3.200 GHz
        Logical CPU Count: 32
        LLC size: 26.2 MB 
        Cache Allocation Technology
            Level 2 capability: not detected
            Level 3 capability: available

If you want to skip descriptions of detected performance issues in the report,
enter: vtune -report summary -report-knob show-issues=false -r <my_result_dir>.
Alternatively, you may view the report in the csv format: vtune -report
<report_name> -format=csv.

vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions 50 % Finalizing results                               
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              
vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
Running /mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py for run 15
vtune: Warning: Pause command is not supported for managed code profiling. Runtime overhead is still possible. Data size limit may be exceeded.
vtune: Collection paused.
EMON collector successfully paused.
vtune: Collection paused.
vtune: Collection resumed.
vtune: Collection detached.
vtune: Collection stopped.
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions  0 % Finalizing the result                            
vtune: Executing actions  0 % Clearing the database                            
vtune: Executing actions  7 % Clearing the database                            
vtune: Executing actions  7 % Loading raw data to the database                 
vtune: Executing actions  7 % Loading 'systemcollector-567926-c4130-node.v100ub
vtune: Executing actions 12 % Loading 'systemcollector-567926-c4130-node.v100ub
vtune: Executing actions 12 % Loading '567926-567931.0.trace' file             
vtune: Executing actions 12 % Loading 'userapicollector-567931-51eafdec.trace' 
vtune: Executing actions 12 % Loading '/mydata/rbachkaniwala3/code/rajveerb-ml-
vtune: Executing actions 12 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Setting data model parameters                    
vtune: Executing actions 19 % Resolving module symbols                         
vtune: Executing actions 19 % Resolving information for dangling locations     
vtune: Executing actions 19 % Resolving information for `libpthread.so.0'      
vtune: Executing actions 19 % Resolving information for `libc.so.6'            
vtune: Executing actions 19 % Resolving information for `libgomp.so.1'         
vtune: Executing actions 19 % Resolving information for `libtpsstool.so'       
vtune: Executing actions 19 % Resolving information for `python3.10'           
vtune: Executing actions 20 % Resolving information for `python3.10'           
vtune: Executing actions 20 % Resolving information for `libtorch_python.so'   
vtune: Warning: Cannot locate debugging information for file `/opt/intel/oneapi/vtune/2024.0/lib64/libtpsstool.so'.
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_python.so'.

vtune: Executing actions 21 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 21 % Resolving information for `libtorch_cpu.so'      
vtune: Executing actions 22 % Resolving information for `libtorch_cpu.so'      
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_cpu.so'.

vtune: Executing actions 22 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving thread name information                
vtune: Executing actions 24 % Resolving thread name information                
vtune: Executing actions 24 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving interrupt name information             
vtune: Executing actions 26 % Resolving interrupt name information             
vtune: Executing actions 26 % Processing profile metrics and debug information 
vtune: Executing actions 28 % Processing profile metrics and debug information 
vtune: Executing actions 30 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Setting data model parameters                    
vtune: Executing actions 32 % Setting data model parameters                    
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 33 % Precomputing frequently used data                
vtune: Executing actions 35 % Precomputing frequently used data                
vtune: Executing actions 36 % Precomputing frequently used data                
vtune: Executing actions 38 % Precomputing frequently used data                
vtune: Executing actions 38 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Discarding redundant overtime data               
vtune: Executing actions 41 % Discarding redundant overtime data               
vtune: Executing actions 41 % Saving the result                                
vtune: Executing actions 42 % Saving the result                                
vtune: Executing actions 44 % Saving the result                                
vtune: Executing actions 49 % Saving the result                                
vtune: Executing actions 50 % Saving the result                                
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              Elapsed Time: 19.062s
    CPU Time: 5.198s
        Effective Time: 3.633s
        Spin Time: 1.531s
         | A significant portion of CPU time is spent waiting. Use this metric
         | to discover which synchronizations are spinning. Consider adjusting
         | spin wait parameters, changing the lock implementation (for example,
         | by backing off then descheduling), or adjusting the synchronization
         | granularity.
         |
            Imbalance or Serial Spinning: 1.021s
             | The threading runtime function related to time spent on imbalance
             | or serial spinning consumed a significant amount of CPU time.
             | This can be caused by a load imbalance, insufficient concurrency
             | for all working threads, or busy waits of worker threads while
             | serial code is executed. If there is an imbalance, apply dynamic
             | work scheduling or reduce the size of work chunks or tasks. If
             | there is insufficient concurrency, consider collapsing the outer
             | and inner loops. If there is a wait for completion of serial
             | code, explore options for parallelization with Intel Advisor,
             | algorithm, or microarchitecture tuning of the application's
             | serial code with VTune Profiler Basic Hotspots or
             | Microarchitecture Exploration analysis respectively. For OpenMP*
             | applications, use the Per-Barrier OpenMP Potential Gain metric
             | set in the HPC Performance Characterization analysis to discover
             | the reason for high imbalance or serial spin time.
             |
            Lock Contention: 0s
            Other: 0.510s
        Overhead Time: 0.034s
            Creation: 0.008s
            Scheduling: 0s
            Reduction: 0s
            Atomics: 0s
            Other: 0.026s
    Total Thread Count: 16
    Paused Time: 18.731s

Top Hotspots
Function                                                                                                                                                                                                                                                                                                                                                                                                                                                           Module           CPU Time  % of CPU Time(%)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  ---------------  --------  ----------------
c10::function_ref<void (char**, long const*, long, long)>::callback_fn<at::native::AVX2::VectorizedLoop2d<at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(float)#1}, at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(at::vec::AVX2::Vectorized<float>)#2}>>  libtorch_cpu.so    3.633s             69.9%
__kmp_fork_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1       1.411s             27.1%
GOMP_parallel                                                                                                                                                                                                                                                                                                                                                                                                                                                      libgomp.so.1       0.110s              2.1%
__kmp_join_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1       0.036s              0.7%
[OpenMP dispatcher]                                                                                                                                                                                                                                                                                                                                                                                                                                                libgomp.so.1       0.008s              0.2%
Effective Physical Core Utilization: 64.6% (10.329 out of 16)
 | The metric value is low, which may signal a poor physical CPU cores
 | utilization caused by:
 |     - load imbalance
 |     - threading runtime overhead
 |     - contended synchronization
 |     - thread/process underutilization
 |     - incorrect affinity that utilizes logical cores instead of physical
 |       cores
 | Explore sub-metrics to estimate the efficiency of MPI and OpenMP parallelism
 | or run the Locks and Waits analysis to identify parallel bottlenecks for
 | other parallel runtimes.
 |
    Effective Logical Core Utilization: 58.3% (18.659 out of 32)
     | The metric value is low, which may signal a poor logical CPU cores
     | utilization. Consider improving physical core utilization as the first
     | step and then look at opportunities to utilize logical cores, which in
     | some cases can improve processor throughput and overall performance of
     | multi-threaded applications.
     |
Collection and Platform Info
    Application Command Line: /proj/prismgt-PG0/anaconda3/envs/torch2/bin/python "/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py" 
    Operating System: 5.4.0-164-generic DISTRIB_ID=Ubuntu DISTRIB_RELEASE=20.04 DISTRIB_CODENAME=focal DISTRIB_DESCRIPTION="Ubuntu 20.04 LTS"
    Computer Name: c4130-node.v100ubuntu20.prismgt-pg0.wisc.cloudlab.us
    Result Size: 4.6 MB 
    Collection start time: 03:36:59 02/01/2024 UTC
    Collection stop time: 03:37:18 02/01/2024 UTC
    Collector Type: Event-based counting driver,User-mode sampling and tracing
    CPU
        Name: Intel(R) Xeon(R) Processor code named Broadwell
        Frequency: 3.200 GHz
        Logical CPU Count: 32
        LLC size: 26.2 MB 
        Cache Allocation Technology
            Level 2 capability: not detected
            Level 3 capability: available

If you want to skip descriptions of detected performance issues in the report,
enter: vtune -report summary -report-knob show-issues=false -r <my_result_dir>.
Alternatively, you may view the report in the csv format: vtune -report
<report_name> -format=csv.

vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions 50 % Finalizing results                               
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              
vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
Running /mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py for run 16
vtune: Warning: Pause command is not supported for managed code profiling. Runtime overhead is still possible. Data size limit may be exceeded.
vtune: Collection paused.
EMON collector successfully paused.
vtune: Collection paused.
vtune: Collection resumed.
vtune: Collection detached.
vtune: Collection stopped.
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions  0 % Finalizing the result                            
vtune: Executing actions  0 % Clearing the database                            
vtune: Executing actions  7 % Clearing the database                            
vtune: Executing actions  7 % Loading raw data to the database                 
vtune: Executing actions  7 % Loading 'systemcollector-568064-c4130-node.v100ub
vtune: Executing actions 12 % Loading 'systemcollector-568064-c4130-node.v100ub
vtune: Executing actions 12 % Loading '568064-568069.0.trace' file             
vtune: Executing actions 12 % Loading 'userapicollector-568069-a877d267.trace' 
vtune: Executing actions 12 % Loading '/mydata/rbachkaniwala3/code/rajveerb-ml-
vtune: Executing actions 12 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Setting data model parameters                    
vtune: Executing actions 19 % Resolving module symbols                         
vtune: Executing actions 19 % Resolving information for dangling locations     
vtune: Executing actions 19 % Resolving information for `libpthread.so.0'      
vtune: Executing actions 19 % Resolving information for `libc10.so'            
vtune: Executing actions 19 % Resolving information for `libgomp.so.1'         
vtune: Executing actions 19 % Resolving information for `libc.so.6'            
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libc10.so'.

vtune: Executing actions 20 % Resolving information for `libc.so.6'            
vtune: Executing actions 20 % Resolving information for `libtpsstool.so'       
vtune: Executing actions 20 % Resolving information for `python3.10'           
vtune: Executing actions 20 % Resolving information for `libtorch_python.so'   
vtune: Warning: Cannot locate debugging information for file `/opt/intel/oneapi/vtune/2024.0/lib64/libtpsstool.so'.
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_python.so'.

vtune: Executing actions 21 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 21 % Resolving information for `libtorch_cpu.so'      
vtune: Executing actions 22 % Resolving information for `libtorch_cpu.so'      
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_cpu.so'.

vtune: Executing actions 22 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving thread name information                
vtune: Executing actions 24 % Resolving thread name information                
vtune: Executing actions 24 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving interrupt name information             
vtune: Executing actions 26 % Resolving interrupt name information             
vtune: Executing actions 26 % Processing profile metrics and debug information 
vtune: Executing actions 28 % Processing profile metrics and debug information 
vtune: Executing actions 30 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Setting data model parameters                    
vtune: Executing actions 32 % Setting data model parameters                    
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 33 % Precomputing frequently used data                
vtune: Executing actions 35 % Precomputing frequently used data                
vtune: Executing actions 36 % Precomputing frequently used data                
vtune: Executing actions 38 % Precomputing frequently used data                
vtune: Executing actions 38 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Discarding redundant overtime data               
vtune: Executing actions 41 % Discarding redundant overtime data               
vtune: Executing actions 41 % Saving the result                                
vtune: Executing actions 42 % Saving the result                                
vtune: Executing actions 44 % Saving the result                                
vtune: Executing actions 49 % Saving the result                                
vtune: Executing actions 50 % Saving the result                                
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              Elapsed Time: 18.731s
    CPU Time: 5.153s
        Effective Time: 3.787s
        Spin Time: 1.291s
         | A significant portion of CPU time is spent waiting. Use this metric
         | to discover which synchronizations are spinning. Consider adjusting
         | spin wait parameters, changing the lock implementation (for example,
         | by backing off then descheduling), or adjusting the synchronization
         | granularity.
         |
            Imbalance or Serial Spinning: 0.774s
             | The threading runtime function related to time spent on imbalance
             | or serial spinning consumed a significant amount of CPU time.
             | This can be caused by a load imbalance, insufficient concurrency
             | for all working threads, or busy waits of worker threads while
             | serial code is executed. If there is an imbalance, apply dynamic
             | work scheduling or reduce the size of work chunks or tasks. If
             | there is insufficient concurrency, consider collapsing the outer
             | and inner loops. If there is a wait for completion of serial
             | code, explore options for parallelization with Intel Advisor,
             | algorithm, or microarchitecture tuning of the application's
             | serial code with VTune Profiler Basic Hotspots or
             | Microarchitecture Exploration analysis respectively. For OpenMP*
             | applications, use the Per-Barrier OpenMP Potential Gain metric
             | set in the HPC Performance Characterization analysis to discover
             | the reason for high imbalance or serial spin time.
             |
            Lock Contention: 0s
            Other: 0.516s
        Overhead Time: 0.076s
            Creation: 0s
            Scheduling: 0s
            Reduction: 0s
            Atomics: 0s
            Other: 0.076s
    Total Thread Count: 16
    Paused Time: 18.405s

Top Hotspots
Function                                                                                                                                                                                                                                                                                                                                                                                                                                                           Module           CPU Time  % of CPU Time(%)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  ---------------  --------  ----------------
c10::function_ref<void (char**, long const*, long, long)>::callback_fn<at::native::AVX2::VectorizedLoop2d<at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(float)#1}, at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(at::vec::AVX2::Vectorized<float>)#2}>>  libtorch_cpu.so    3.777s             73.3%
__kmp_fork_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1       1.243s             24.1%
GOMP_parallel                                                                                                                                                                                                                                                                                                                                                                                                                                                      libgomp.so.1       0.116s              2.3%
_int_free                                                                                                                                                                                                                                                                                                                                                                                                                                                          libc.so.6          0.010s              0.2%
__kmp_join_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1       0.008s              0.2%
Effective Physical Core Utilization: 60.5% (9.677 out of 16)
 | The metric value is low, which may signal a poor physical CPU cores
 | utilization caused by:
 |     - load imbalance
 |     - threading runtime overhead
 |     - contended synchronization
 |     - thread/process underutilization
 |     - incorrect affinity that utilizes logical cores instead of physical
 |       cores
 | Explore sub-metrics to estimate the efficiency of MPI and OpenMP parallelism
 | or run the Locks and Waits analysis to identify parallel bottlenecks for
 | other parallel runtimes.
 |
    Effective Logical Core Utilization: 49.4% (15.812 out of 32)
     | The metric value is low, which may signal a poor logical CPU cores
     | utilization. Consider improving physical core utilization as the first
     | step and then look at opportunities to utilize logical cores, which in
     | some cases can improve processor throughput and overall performance of
     | multi-threaded applications.
     |
Collection and Platform Info
    Application Command Line: /proj/prismgt-PG0/anaconda3/envs/torch2/bin/python "/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py" 
    Operating System: 5.4.0-164-generic DISTRIB_ID=Ubuntu DISTRIB_RELEASE=20.04 DISTRIB_CODENAME=focal DISTRIB_DESCRIPTION="Ubuntu 20.04 LTS"
    Computer Name: c4130-node.v100ubuntu20.prismgt-pg0.wisc.cloudlab.us
    Result Size: 4.6 MB 
    Collection start time: 03:37:35 02/01/2024 UTC
    Collection stop time: 03:37:53 02/01/2024 UTC
    Collector Type: Event-based counting driver,User-mode sampling and tracing
    CPU
        Name: Intel(R) Xeon(R) Processor code named Broadwell
        Frequency: 3.200 GHz
        Logical CPU Count: 32
        LLC size: 26.2 MB 
        Cache Allocation Technology
            Level 2 capability: not detected
            Level 3 capability: available

If you want to skip descriptions of detected performance issues in the report,
enter: vtune -report summary -report-knob show-issues=false -r <my_result_dir>.
Alternatively, you may view the report in the csv format: vtune -report
<report_name> -format=csv.

vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions 50 % Finalizing results                               
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              
vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
Running /mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py for run 17
vtune: Warning: Pause command is not supported for managed code profiling. Runtime overhead is still possible. Data size limit may be exceeded.
vtune: Collection paused.
EMON collector successfully paused.
vtune: Collection paused.
vtune: Collection resumed.
vtune: Collection detached.
vtune: Collection stopped.
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions  0 % Finalizing the result                            
vtune: Executing actions  0 % Clearing the database                            
vtune: Executing actions  7 % Clearing the database                            
vtune: Executing actions  7 % Loading raw data to the database                 
vtune: Executing actions  7 % Loading 'systemcollector-568199-c4130-node.v100ub
vtune: Executing actions 12 % Loading 'systemcollector-568199-c4130-node.v100ub
vtune: Executing actions 12 % Loading '568199-568206.0.trace' file             
vtune: Executing actions 12 % Loading 'userapicollector-568206-e7fbf161.trace' 
vtune: Executing actions 12 % Loading '/mydata/rbachkaniwala3/code/rajveerb-ml-
vtune: Executing actions 12 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Setting data model parameters                    
vtune: Executing actions 19 % Resolving module symbols                         
vtune: Executing actions 19 % Resolving information for dangling locations     
vtune: Executing actions 19 % Resolving information for `libc.so.6'            
vtune: Executing actions 19 % Resolving information for `libgomp.so.1'         
vtune: Executing actions 19 % Resolving information for `libc10.so'            
vtune: Executing actions 19 % Resolving information for `libpthread.so.0'      
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libc10.so'.

vtune: Executing actions 19 % Resolving information for `libtpsstool.so'       
vtune: Executing actions 20 % Resolving information for `libtpsstool.so'       
vtune: Executing actions 20 % Resolving information for `python3.10'           
vtune: Executing actions 20 % Resolving information for `libtorch_python.so'   
vtune: Warning: Cannot locate debugging information for file `/opt/intel/oneapi/vtune/2024.0/lib64/libtpsstool.so'.
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_python.so'.

vtune: Executing actions 21 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 22 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 22 % Resolving information for `libtorch_cpu.so'      
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_cpu.so'.

vtune: Executing actions 22 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving thread name information                
vtune: Executing actions 24 % Resolving thread name information                
vtune: Executing actions 24 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving interrupt name information             
vtune: Executing actions 26 % Resolving interrupt name information             
vtune: Executing actions 26 % Processing profile metrics and debug information 
vtune: Executing actions 28 % Processing profile metrics and debug information 
vtune: Executing actions 30 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Setting data model parameters                    
vtune: Executing actions 32 % Setting data model parameters                    
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 33 % Precomputing frequently used data                
vtune: Executing actions 35 % Precomputing frequently used data                
vtune: Executing actions 36 % Precomputing frequently used data                
vtune: Executing actions 38 % Precomputing frequently used data                
vtune: Executing actions 38 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Discarding redundant overtime data               
vtune: Executing actions 41 % Discarding redundant overtime data               
vtune: Executing actions 41 % Saving the result                                
vtune: Executing actions 42 % Saving the result                                
vtune: Executing actions 44 % Saving the result                                
vtune: Executing actions 50 % Saving the result                                
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              Elapsed Time: 19.054s
    CPU Time: 5.433s
        Effective Time: 4.197s
        Spin Time: 1.184s
         | A significant portion of CPU time is spent waiting. Use this metric
         | to discover which synchronizations are spinning. Consider adjusting
         | spin wait parameters, changing the lock implementation (for example,
         | by backing off then descheduling), or adjusting the synchronization
         | granularity.
         |
            Imbalance or Serial Spinning: 0.688s
             | The threading runtime function related to time spent on imbalance
             | or serial spinning consumed a significant amount of CPU time.
             | This can be caused by a load imbalance, insufficient concurrency
             | for all working threads, or busy waits of worker threads while
             | serial code is executed. If there is an imbalance, apply dynamic
             | work scheduling or reduce the size of work chunks or tasks. If
             | there is insufficient concurrency, consider collapsing the outer
             | and inner loops. If there is a wait for completion of serial
             | code, explore options for parallelization with Intel Advisor,
             | algorithm, or microarchitecture tuning of the application's
             | serial code with VTune Profiler Basic Hotspots or
             | Microarchitecture Exploration analysis respectively. For OpenMP*
             | applications, use the Per-Barrier OpenMP Potential Gain metric
             | set in the HPC Performance Characterization analysis to discover
             | the reason for high imbalance or serial spin time.
             |
            Lock Contention: 0s
            Other: 0.497s
        Overhead Time: 0.052s
            Creation: 0s
            Scheduling: 0s
            Reduction: 0s
            Atomics: 0s
            Other: 0.052s
    Total Thread Count: 16
    Paused Time: 18.710s

Top Hotspots
Function                                                                                                                                                                                                                                                                                                                                                                                                                                                           Module           CPU Time  % of CPU Time(%)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  ---------------  --------  ----------------
c10::function_ref<void (char**, long const*, long, long)>::callback_fn<at::native::AVX2::VectorizedLoop2d<at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(float)#1}, at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(at::vec::AVX2::Vectorized<float>)#2}>>  libtorch_cpu.so    4.187s             77.1%
__kmp_fork_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1       1.001s             18.4%
__kmp_join_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1       0.124s              2.3%
GOMP_parallel                                                                                                                                                                                                                                                                                                                                                                                                                                                      libgomp.so.1       0.112s              2.1%
_int_free                                                                                                                                                                                                                                                                                                                                                                                                                                                          libc.so.6          0.010s              0.2%
Effective Physical Core Utilization: 86.3% (13.805 out of 16)
    Effective Logical Core Utilization: 72.0% (23.043 out of 32)
     | The metric value is low, which may signal a poor utilization of logical
     | CPU cores while the utilization of physical cores is acceptable. Consider
     | using logical cores, which in some cases can improve processor throughput
     | and overall performance of multi-threaded applications.
     |
Collection and Platform Info
    Application Command Line: /proj/prismgt-PG0/anaconda3/envs/torch2/bin/python "/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py" 
    Operating System: 5.4.0-164-generic DISTRIB_ID=Ubuntu DISTRIB_RELEASE=20.04 DISTRIB_CODENAME=focal DISTRIB_DESCRIPTION="Ubuntu 20.04 LTS"
    Computer Name: c4130-node.v100ubuntu20.prismgt-pg0.wisc.cloudlab.us
    Result Size: 4.6 MB 
    Collection start time: 03:38:10 02/01/2024 UTC
    Collection stop time: 03:38:29 02/01/2024 UTC
    Collector Type: Event-based counting driver,User-mode sampling and tracing
    CPU
        Name: Intel(R) Xeon(R) Processor code named Broadwell
        Frequency: 3.200 GHz
        Logical CPU Count: 32
        LLC size: 26.2 MB 
        Cache Allocation Technology
            Level 2 capability: not detected
            Level 3 capability: available

If you want to skip descriptions of detected performance issues in the report,
enter: vtune -report summary -report-knob show-issues=false -r <my_result_dir>.
Alternatively, you may view the report in the csv format: vtune -report
<report_name> -format=csv.

vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions 50 % Finalizing results                               
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              
vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
Running /mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py for run 18
vtune: Warning: Pause command is not supported for managed code profiling. Runtime overhead is still possible. Data size limit may be exceeded.
vtune: Collection paused.
EMON collector successfully paused.
vtune: Collection paused.
vtune: Collection resumed.
vtune: Collection detached.
vtune: Collection stopped.
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions  0 % Finalizing the result                            
vtune: Executing actions  0 % Clearing the database                            
vtune: Executing actions  7 % Clearing the database                            
vtune: Executing actions  7 % Loading raw data to the database                 
vtune: Executing actions  7 % Loading 'systemcollector-568323-c4130-node.v100ub
vtune: Executing actions 12 % Loading 'systemcollector-568323-c4130-node.v100ub
vtune: Executing actions 12 % Loading '568323-568328.0.trace' file             
vtune: Executing actions 12 % Loading 'userapicollector-568328-5700884d.trace' 
vtune: Executing actions 12 % Loading '/mydata/rbachkaniwala3/code/rajveerb-ml-
vtune: Executing actions 12 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Setting data model parameters                    
vtune: Executing actions 19 % Resolving module symbols                         
vtune: Executing actions 19 % Resolving information for dangling locations     
vtune: Executing actions 19 % Resolving information for `libpthread.so.0'      
vtune: Executing actions 19 % Resolving information for `libc.so.6'            
vtune: Executing actions 19 % Resolving information for `libgomp.so.1'         
vtune: Executing actions 19 % Resolving information for `libtpsstool.so'       
vtune: Executing actions 19 % Resolving information for `python3.10'           
vtune: Executing actions 19 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 20 % Resolving information for `libtorch_python.so'   
vtune: Warning: Cannot locate debugging information for file `/opt/intel/oneapi/vtune/2024.0/lib64/libtpsstool.so'.
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_python.so'.

vtune: Executing actions 21 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 21 % Resolving information for `libtorch_cpu.so'      
vtune: Executing actions 22 % Resolving information for `libtorch_cpu.so'      
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_cpu.so'.

vtune: Executing actions 22 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving thread name information                
vtune: Executing actions 24 % Resolving thread name information                
vtune: Executing actions 24 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving interrupt name information             
vtune: Executing actions 26 % Resolving interrupt name information             
vtune: Executing actions 26 % Processing profile metrics and debug information 
vtune: Executing actions 28 % Processing profile metrics and debug information 
vtune: Executing actions 30 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Setting data model parameters                    
vtune: Executing actions 32 % Setting data model parameters                    
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 33 % Precomputing frequently used data                
vtune: Executing actions 35 % Precomputing frequently used data                
vtune: Executing actions 36 % Precomputing frequently used data                
vtune: Executing actions 38 % Precomputing frequently used data                
vtune: Executing actions 38 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Discarding redundant overtime data               
vtune: Executing actions 41 % Discarding redundant overtime data               
vtune: Executing actions 41 % Saving the result                                
vtune: Executing actions 42 % Saving the result                                
vtune: Executing actions 44 % Saving the result                                
vtune: Executing actions 50 % Saving the result                                
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              Elapsed Time: 17.151s
    CPU Time: 6.965s
        Effective Time: 5.286s
        Spin Time: 1.633s
         | A significant portion of CPU time is spent waiting. Use this metric
         | to discover which synchronizations are spinning. Consider adjusting
         | spin wait parameters, changing the lock implementation (for example,
         | by backing off then descheduling), or adjusting the synchronization
         | granularity.
         |
            Imbalance or Serial Spinning: 0.938s
             | The threading runtime function related to time spent on imbalance
             | or serial spinning consumed a significant amount of CPU time.
             | This can be caused by a load imbalance, insufficient concurrency
             | for all working threads, or busy waits of worker threads while
             | serial code is executed. If there is an imbalance, apply dynamic
             | work scheduling or reduce the size of work chunks or tasks. If
             | there is insufficient concurrency, consider collapsing the outer
             | and inner loops. If there is a wait for completion of serial
             | code, explore options for parallelization with Intel Advisor,
             | algorithm, or microarchitecture tuning of the application's
             | serial code with VTune Profiler Basic Hotspots or
             | Microarchitecture Exploration analysis respectively. For OpenMP*
             | applications, use the Per-Barrier OpenMP Potential Gain metric
             | set in the HPC Performance Characterization analysis to discover
             | the reason for high imbalance or serial spin time.
             |
            Lock Contention: 0s
            Other: 0.696s
        Overhead Time: 0.045s
            Creation: 0.009s
            Scheduling: 0s
            Reduction: 0s
            Atomics: 0s
            Other: 0.036s
    Total Thread Count: 16
    Paused Time: 16.711s

Top Hotspots
Function                                                                                                                                                                                                                                                                                                                                                                                                                                                           Module           CPU Time  % of CPU Time(%)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  ---------------  --------  ----------------
c10::function_ref<void (char**, long const*, long, long)>::callback_fn<at::native::AVX2::VectorizedLoop2d<at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(float)#1}, at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(at::vec::AVX2::Vectorized<float>)#2}>>  libtorch_cpu.so    5.286s             75.9%
__kmp_fork_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1       1.509s             21.7%
GOMP_parallel                                                                                                                                                                                                                                                                                                                                                                                                                                                      libgomp.so.1       0.140s              2.0%
__kmp_join_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1       0.020s              0.3%
[OpenMP dispatcher]                                                                                                                                                                                                                                                                                                                                                                                                                                                libgomp.so.1       0.009s              0.1%
Effective Physical Core Utilization: 70.8% (11.331 out of 16)
 | The metric value is low, which may signal a poor physical CPU cores
 | utilization caused by:
 |     - load imbalance
 |     - threading runtime overhead
 |     - contended synchronization
 |     - thread/process underutilization
 |     - incorrect affinity that utilizes logical cores instead of physical
 |       cores
 | Explore sub-metrics to estimate the efficiency of MPI and OpenMP parallelism
 | or run the Locks and Waits analysis to identify parallel bottlenecks for
 | other parallel runtimes.
 |
    Effective Logical Core Utilization: 55.3% (17.689 out of 32)
     | The metric value is low, which may signal a poor logical CPU cores
     | utilization. Consider improving physical core utilization as the first
     | step and then look at opportunities to utilize logical cores, which in
     | some cases can improve processor throughput and overall performance of
     | multi-threaded applications.
     |
Collection and Platform Info
    Application Command Line: /proj/prismgt-PG0/anaconda3/envs/torch2/bin/python "/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py" 
    Operating System: 5.4.0-164-generic DISTRIB_ID=Ubuntu DISTRIB_RELEASE=20.04 DISTRIB_CODENAME=focal DISTRIB_DESCRIPTION="Ubuntu 20.04 LTS"
    Computer Name: c4130-node.v100ubuntu20.prismgt-pg0.wisc.cloudlab.us
    Result Size: 4.6 MB 
    Collection start time: 03:38:46 02/01/2024 UTC
    Collection stop time: 03:39:03 02/01/2024 UTC
    Collector Type: Event-based counting driver,User-mode sampling and tracing
    CPU
        Name: Intel(R) Xeon(R) Processor code named Broadwell
        Frequency: 3.200 GHz
        Logical CPU Count: 32
        LLC size: 26.2 MB 
        Cache Allocation Technology
            Level 2 capability: not detected
            Level 3 capability: available

If you want to skip descriptions of detected performance issues in the report,
enter: vtune -report summary -report-knob show-issues=false -r <my_result_dir>.
Alternatively, you may view the report in the csv format: vtune -report
<report_name> -format=csv.

vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions 50 % Finalizing results                               
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              
vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
Running /mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py for run 19
vtune: Warning: Pause command is not supported for managed code profiling. Runtime overhead is still possible. Data size limit may be exceeded.
vtune: Collection paused.
EMON collector successfully paused.
vtune: Collection paused.
vtune: Collection resumed.
vtune: Collection detached.
vtune: Collection stopped.
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions  0 % Finalizing the result                            
vtune: Executing actions  0 % Clearing the database                            
vtune: Executing actions  7 % Clearing the database                            
vtune: Executing actions  7 % Loading raw data to the database                 
vtune: Executing actions  7 % Loading 'systemcollector-568449-c4130-node.v100ub
vtune: Executing actions 12 % Loading 'systemcollector-568449-c4130-node.v100ub
vtune: Executing actions 12 % Loading '568449-568454.0.trace' file             
vtune: Executing actions 12 % Loading 'userapicollector-568454-366a9d98.trace' 
vtune: Executing actions 12 % Loading '/mydata/rbachkaniwala3/code/rajveerb-ml-
vtune: Executing actions 12 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Setting data model parameters                    
vtune: Executing actions 19 % Resolving module symbols                         
vtune: Executing actions 19 % Resolving information for dangling locations     
vtune: Executing actions 19 % Resolving information for `libc.so.6'            
vtune: Executing actions 19 % Resolving information for `libpthread.so.0'      
vtune: Executing actions 19 % Resolving information for `libgomp.so.1'         
vtune: Executing actions 19 % Resolving information for `ld-linux-x86-64.so.2' 
vtune: Executing actions 19 % Resolving information for `libtpsstool.so'       
vtune: Executing actions 20 % Resolving information for `libtpsstool.so'       
vtune: Executing actions 20 % Resolving information for `python3.10'           
vtune: Executing actions 20 % Resolving information for `libtorch_python.so'   
vtune: Warning: Cannot locate debugging information for file `/opt/intel/oneapi/vtune/2024.0/lib64/libtpsstool.so'.
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_python.so'.

vtune: Executing actions 21 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 22 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 22 % Resolving information for `libtorch_cpu.so'      
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_cpu.so'.

vtune: Executing actions 22 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving thread name information                
vtune: Executing actions 24 % Resolving thread name information                
vtune: Executing actions 24 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving interrupt name information             
vtune: Executing actions 26 % Resolving interrupt name information             
vtune: Executing actions 26 % Processing profile metrics and debug information 
vtune: Executing actions 28 % Processing profile metrics and debug information 
vtune: Executing actions 30 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Setting data model parameters                    
vtune: Executing actions 32 % Setting data model parameters                    
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 33 % Precomputing frequently used data                
vtune: Executing actions 35 % Precomputing frequently used data                
vtune: Executing actions 36 % Precomputing frequently used data                
vtune: Executing actions 38 % Precomputing frequently used data                
vtune: Executing actions 38 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Discarding redundant overtime data               
vtune: Executing actions 41 % Discarding redundant overtime data               
vtune: Executing actions 41 % Saving the result                                
vtune: Executing actions 42 % Saving the result                                
vtune: Executing actions 44 % Saving the result                                
vtune: Executing actions 49 % Saving the result                                
vtune: Executing actions 50 % Saving the result                                
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              Elapsed Time: 19.153s
    CPU Time: 5.566s
        Effective Time: 4.119s
        Spin Time: 1.379s
         | A significant portion of CPU time is spent waiting. Use this metric
         | to discover which synchronizations are spinning. Consider adjusting
         | spin wait parameters, changing the lock implementation (for example,
         | by backing off then descheduling), or adjusting the synchronization
         | granularity.
         |
            Imbalance or Serial Spinning: 0.848s
             | The threading runtime function related to time spent on imbalance
             | or serial spinning consumed a significant amount of CPU time.
             | This can be caused by a load imbalance, insufficient concurrency
             | for all working threads, or busy waits of worker threads while
             | serial code is executed. If there is an imbalance, apply dynamic
             | work scheduling or reduce the size of work chunks or tasks. If
             | there is insufficient concurrency, consider collapsing the outer
             | and inner loops. If there is a wait for completion of serial
             | code, explore options for parallelization with Intel Advisor,
             | algorithm, or microarchitecture tuning of the application's
             | serial code with VTune Profiler Basic Hotspots or
             | Microarchitecture Exploration analysis respectively. For OpenMP*
             | applications, use the Per-Barrier OpenMP Potential Gain metric
             | set in the HPC Performance Characterization analysis to discover
             | the reason for high imbalance or serial spin time.
             |
            Lock Contention: 0s
            Other: 0.532s
        Overhead Time: 0.068s
            Creation: 0s
            Scheduling: 0s
            Reduction: 0s
            Atomics: 0s
            Other: 0.068s
    Total Thread Count: 16
    Paused Time: 18.797s

Top Hotspots
Function                                                                                                                                                                                                                                                                                                                                                                                                                                                           Module                CPU Time  % of CPU Time(%)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  --------------------  --------  ----------------
c10::function_ref<void (char**, long const*, long, long)>::callback_fn<at::native::AVX2::VectorizedLoop2d<at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(float)#1}, at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(at::vec::AVX2::Vectorized<float>)#2}>>  libtorch_cpu.so         4.111s             73.9%
__kmp_fork_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1            1.273s             22.9%
GOMP_parallel                                                                                                                                                                                                                                                                                                                                                                                                                                                      libgomp.so.1            0.134s              2.4%
__kmp_join_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1            0.040s              0.7%
__tls_get_addr                                                                                                                                                                                                                                                                                                                                                                                                                                                     ld-linux-x86-64.so.2    0.008s              0.1%
Effective Physical Core Utilization: 50.5% (8.087 out of 16)
 | The metric value is low, which may signal a poor physical CPU cores
 | utilization caused by:
 |     - load imbalance
 |     - threading runtime overhead
 |     - contended synchronization
 |     - thread/process underutilization
 |     - incorrect affinity that utilizes logical cores instead of physical
 |       cores
 | Explore sub-metrics to estimate the efficiency of MPI and OpenMP parallelism
 | or run the Locks and Waits analysis to identify parallel bottlenecks for
 | other parallel runtimes.
 |
    Effective Logical Core Utilization: 45.4% (14.534 out of 32)
     | The metric value is low, which may signal a poor logical CPU cores
     | utilization. Consider improving physical core utilization as the first
     | step and then look at opportunities to utilize logical cores, which in
     | some cases can improve processor throughput and overall performance of
     | multi-threaded applications.
     |
Collection and Platform Info
    Application Command Line: /proj/prismgt-PG0/anaconda3/envs/torch2/bin/python "/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py" 
    Operating System: 5.4.0-164-generic DISTRIB_ID=Ubuntu DISTRIB_RELEASE=20.04 DISTRIB_CODENAME=focal DISTRIB_DESCRIPTION="Ubuntu 20.04 LTS"
    Computer Name: c4130-node.v100ubuntu20.prismgt-pg0.wisc.cloudlab.us
    Result Size: 4.5 MB 
    Collection start time: 03:39:20 02/01/2024 UTC
    Collection stop time: 03:39:39 02/01/2024 UTC
    Collector Type: Event-based counting driver,User-mode sampling and tracing
    CPU
        Name: Intel(R) Xeon(R) Processor code named Broadwell
        Frequency: 3.200 GHz
        Logical CPU Count: 32
        LLC size: 26.2 MB 
        Cache Allocation Technology
            Level 2 capability: not detected
            Level 3 capability: available

If you want to skip descriptions of detected performance issues in the report,
enter: vtune -report summary -report-knob show-issues=false -r <my_result_dir>.
Alternatively, you may view the report in the csv format: vtune -report
<report_name> -format=csv.

vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions 50 % Finalizing results                               
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              
vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
Running /mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py for run 20
vtune: Warning: Pause command is not supported for managed code profiling. Runtime overhead is still possible. Data size limit may be exceeded.
vtune: Collection paused.
EMON collector successfully paused.
vtune: Collection paused.
vtune: Collection resumed.
vtune: Collection detached.
vtune: Collection stopped.
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions  0 % Finalizing the result                            
vtune: Executing actions  0 % Clearing the database                            
vtune: Executing actions  7 % Clearing the database                            
vtune: Executing actions  7 % Loading raw data to the database                 
vtune: Executing actions  7 % Loading 'systemcollector-568582-c4130-node.v100ub
vtune: Executing actions 12 % Loading 'systemcollector-568582-c4130-node.v100ub
vtune: Executing actions 12 % Loading '568582-568587.0.trace' file             
vtune: Executing actions 12 % Loading 'userapicollector-568587-90964502.trace' 
vtune: Executing actions 12 % Loading '/mydata/rbachkaniwala3/code/rajveerb-ml-
vtune: Executing actions 12 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Updating precomputed scalar metrics              
vtune: Executing actions 14 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Processing profile metrics and debug information 
vtune: Executing actions 19 % Setting data model parameters                    
vtune: Executing actions 19 % Resolving module symbols                         
vtune: Executing actions 19 % Resolving information for dangling locations     
vtune: Executing actions 19 % Resolving information for `libpthread.so.0'      
vtune: Executing actions 19 % Resolving information for `libc.so.6'            
vtune: Executing actions 19 % Resolving information for `libgomp.so.1'         
vtune: Executing actions 19 % Resolving information for `libtpsstool.so'       
vtune: Executing actions 19 % Resolving information for `python3.10'           
vtune: Executing actions 19 % Resolving information for `libtorch_python.so'   
vtune: Warning: Cannot locate debugging information for file `/opt/intel/oneapi/vtune/2024.0/lib64/libtpsstool.so'.

vtune: Executing actions 20 % Resolving information for `libtorch_python.so'   
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_python.so'.

vtune: Executing actions 21 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 22 % Resolving information for `libtorch_python.so'   
vtune: Executing actions 22 % Resolving information for `libtorch_cpu.so'      
vtune: Warning: Cannot locate debugging information for file `/proj/prismgt-PG0/anaconda3/envs/torch2/lib/python3.10/site-packages/torch/lib/libtorch_cpu.so'.

vtune: Executing actions 22 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving bottom user stack information          
vtune: Executing actions 23 % Resolving thread name information                
vtune: Executing actions 24 % Resolving thread name information                
vtune: Executing actions 24 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving call target names for dynamic code     
vtune: Executing actions 25 % Resolving interrupt name information             
vtune: Executing actions 26 % Resolving interrupt name information             
vtune: Executing actions 26 % Processing profile metrics and debug information 
vtune: Executing actions 28 % Processing profile metrics and debug information 
vtune: Executing actions 30 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Processing profile metrics and debug information 
vtune: Executing actions 31 % Setting data model parameters                    
vtune: Executing actions 32 % Setting data model parameters                    
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 32 % Precomputing frequently used data                
vtune: Executing actions 33 % Precomputing frequently used data                
vtune: Executing actions 35 % Precomputing frequently used data                
vtune: Executing actions 36 % Precomputing frequently used data                
vtune: Executing actions 38 % Precomputing frequently used data                
vtune: Executing actions 38 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Updating precomputed scalar metrics              
vtune: Executing actions 39 % Discarding redundant overtime data               
vtune: Executing actions 41 % Discarding redundant overtime data               
vtune: Executing actions 41 % Saving the result                                
vtune: Executing actions 42 % Saving the result                                
vtune: Executing actions 44 % Saving the result                                
vtune: Executing actions 50 % Saving the result                                
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              Elapsed Time: 18.620s
    CPU Time: 5.485s
        Effective Time: 4.224s
        Spin Time: 1.205s
         | A significant portion of CPU time is spent waiting. Use this metric
         | to discover which synchronizations are spinning. Consider adjusting
         | spin wait parameters, changing the lock implementation (for example,
         | by backing off then descheduling), or adjusting the synchronization
         | granularity.
         |
            Imbalance or Serial Spinning: 0.672s
             | The threading runtime function related to time spent on imbalance
             | or serial spinning consumed a significant amount of CPU time.
             | This can be caused by a load imbalance, insufficient concurrency
             | for all working threads, or busy waits of worker threads while
             | serial code is executed. If there is an imbalance, apply dynamic
             | work scheduling or reduce the size of work chunks or tasks. If
             | there is insufficient concurrency, consider collapsing the outer
             | and inner loops. If there is a wait for completion of serial
             | code, explore options for parallelization with Intel Advisor,
             | algorithm, or microarchitecture tuning of the application's
             | serial code with VTune Profiler Basic Hotspots or
             | Microarchitecture Exploration analysis respectively. For OpenMP*
             | applications, use the Per-Barrier OpenMP Potential Gain metric
             | set in the HPC Performance Characterization analysis to discover
             | the reason for high imbalance or serial spin time.
             |
            Lock Contention: 0s
            Other: 0.533s
        Overhead Time: 0.056s
            Creation: 0.016s
            Scheduling: 0s
            Reduction: 0s
            Atomics: 0s
            Other: 0.040s
    Total Thread Count: 16
    Paused Time: 18.271s

Top Hotspots
Function                                                                                                                                                                                                                                                                                                                                                                                                                                                           Module           CPU Time  % of CPU Time(%)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  ---------------  --------  ----------------
c10::function_ref<void (char**, long const*, long, long)>::callback_fn<at::native::AVX2::VectorizedLoop2d<at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(float)#1}, at::native::AVX2::direct_copy_kernel(at::TensorIteratorBase&)::{lambda()#3}::operator()(void) const::{lambda()#7}::operator()(void) const::{lambda(at::vec::AVX2::Vectorized<float>)#2}>>  libtorch_cpu.so    4.224s             77.0%
__kmp_fork_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1       1.049s             19.1%
GOMP_parallel                                                                                                                                                                                                                                                                                                                                                                                                                                                      libgomp.so.1       0.116s              2.1%
__kmp_join_barrier                                                                                                                                                                                                                                                                                                                                                                                                                                                 libgomp.so.1       0.080s              1.5%
[OpenMP dispatcher]                                                                                                                                                                                                                                                                                                                                                                                                                                                libgomp.so.1       0.008s              0.1%
__GI___pthread_getspecific                                                                                                                                                                                                                                                                                                                                                                                                                                         libpthread.so.0    0.008s              0.1%
Effective Physical Core Utilization: 78.3% (12.527 out of 16)
 | The metric value is low, which may signal a poor physical CPU cores
 | utilization caused by:
 |     - load imbalance
 |     - threading runtime overhead
 |     - contended synchronization
 |     - thread/process underutilization
 |     - incorrect affinity that utilizes logical cores instead of physical
 |       cores
 | Explore sub-metrics to estimate the efficiency of MPI and OpenMP parallelism
 | or run the Locks and Waits analysis to identify parallel bottlenecks for
 | other parallel runtimes.
 |
    Effective Logical Core Utilization: 64.9% (20.782 out of 32)
     | The metric value is low, which may signal a poor logical CPU cores
     | utilization. Consider improving physical core utilization as the first
     | step and then look at opportunities to utilize logical cores, which in
     | some cases can improve processor throughput and overall performance of
     | multi-threaded applications.
     |
Collection and Platform Info
    Application Command Line: /proj/prismgt-PG0/anaconda3/envs/torch2/bin/python "/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/code/image_classification/analysis/low_level_func/Collation.py" 
    Operating System: 5.4.0-164-generic DISTRIB_ID=Ubuntu DISTRIB_RELEASE=20.04 DISTRIB_CODENAME=focal DISTRIB_DESCRIPTION="Ubuntu 20.04 LTS"
    Computer Name: c4130-node.v100ubuntu20.prismgt-pg0.wisc.cloudlab.us
    Result Size: 4.6 MB 
    Collection start time: 03:39:56 02/01/2024 UTC
    Collection stop time: 03:40:15 02/01/2024 UTC
    Collector Type: Event-based counting driver,User-mode sampling and tracing
    CPU
        Name: Intel(R) Xeon(R) Processor code named Broadwell
        Frequency: 3.200 GHz
        Logical CPU Count: 32
        LLC size: 26.2 MB 
        Cache Allocation Technology
            Level 2 capability: not detected
            Level 3 capability: available

If you want to skip descriptions of detected performance issues in the report,
enter: vtune -report summary -report-knob show-issues=false -r <my_result_dir>.
Alternatively, you may view the report in the csv format: vtune -report
<report_name> -format=csv.

vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
vtune: Using result path `/mydata/rbachkaniwala3/code/rajveerb-ml-pipeline-benchmark/low_level_func'

vtune: Executing actions  0 %                                                  
vtune: Executing actions  0 % Finalizing results                               
vtune: Executing actions 50 % Finalizing results                               
vtune: Executing actions 50 % Generating a report                              
vtune: Executing actions 50 % Setting data model parameters                    
vtune: Executing actions 75 % Setting data model parameters                    
vtune: Executing actions 75 % Generating a report                              
vtune: Executing actions 100 % Generating a report                             
vtune: Executing actions 100 % done                                            
Done running all programs
